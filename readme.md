# Шпаргалка по консольным командам Git

## Общее

Git — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). **Важно:** добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (git add), потом «сохраняем» (git commit).

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые, изменённые, проиндексированные (готовые к коммиту).

### Ключ к пониманию

Ключ к пониманию концепции git — знание о «трех деревьях»:

- Рабочая директория — файловая система проекта (те файлы, с которыми вы работаете).

* Индекс — список отслеживаемых git-ом файлов и директорий, промежуточное хранилище изменений (редактирование, удаление отслеживаемых файлов).

+ Директория .git/ — все данные контроля версий этого проекта (вся история разработки: коммиты, ветки, теги и пр.).

**Коммит** — «сохранение» (хранит набор изменений, сделанный в рабочей директории с момента предыдущего коммита). Коммит неизменен, его нельзя отредактировать.

У всех коммитов (кроме самого первого) есть один или более родительских коммитов, поскольку коммиты хранят изменения от предыдущих состояний.

### Простейший цикл работ:

* Редактирование, добавление, удаление файлов (собственно, работа).
* Индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).
* Коммит (фиксация изменений).
* Возврат к шагу 1 или отход ко сну.

### Указатели:
- **HEAD** — указатель на текущий коммит или на текущую ветку (то есть, в любом случае, на коммит). Указывает на родителя коммита, который будет создан следующим.
- **ORIG_HEAD** — указатель на коммит, с которого вы только что переместили HEAD (командой git reset ..., например).
- **Ветка** (master, develop etc.) — указатель на коммит. При добавлении коммита, указатель ветки перемещается с родительского коммита на новый.
- **Теги** — простые указатели на коммиты. Не перемещаются.

## Настройки

**Перед началом работы нужно выполнить некоторые настройки:**

*`git config --global user.name "Your Name" # указать имя, которым будут подписаны коммиты`*

*`git config --global user.email "e@w.com"  # указать электропочту, которая будет в описании коммитера`*

*`git config --global core.autocrlf true # Включит в преобразование окончаний строк из CRLF в LF`*

**И**

*`git config --global core.safecrlf true`*

*`git config -global core.editor vim (nano, code, pstorm, и т.д.)`*

## Указание неотслеживаемых файлов

Файлы и директории, которые не нужно включать в репозиторий, указываются в файле **.gitignore**. Обычно это устанавливаемые зависимости **(node_modules/, bower_components/)**, готовая сборка **build/** или **dist/** и подобные, создаваемые при установке или запуске. Каждый файл или директория указываются с новой строки, возможно использование шаблонов.

# Шпаргалка по bash

## Суть

**Консоль** — удобный и быстрый инструмент управления компьютером. Вводим команду текстом, получаем результат или сообщение об ошибке с указанием в чём ошибка.

Работая с консолью, мы всегда «находимся» в какой-то папке (это указано в строке над курсором). Если там написано **~**, то мы в папке пользователя (зависит от настроек Windows, чаще всего это **C:/Users/ВАШЕИМЯПОЛЬЗОВАТЕЛЯ/)**, если там **/d/projects**, мы в папке **D:/projects.**

## Файловая система

### Просмотр содержимого папки

`pwd                     # выводит текущи путь (сокращение от PRINT WORK DIRECTORY)`

`ls                      # показать содержимое папки`

`ls -l                   # отображает расширенную информацию о файлах и папках`

`ls -a                   # то же, но показывать и скрытые файлы и папки`

`ls -a -1                # то же, но в один столбец`

`ls -hF -1 --sort=extension # показать содержимое папки «красиво, в один столбец»`

`ls build/css            # показать содержимое папки ТЕКУЩАЯ_ПАПКА/build/css`

`ls /d/projects          # показать содержимое папки D:/projects`


## Перемещение по файловой системе

*Пользователь всегда находится в какой-то папке, она (или полный путь) всегда показана до области ввода команд.*

`cd projects             # переход в папку projects, которая есть текущей папке`

`cd /d/projects          # windows: переход в папку projects, расположенную по адресу D:/projects`

`cd /c/Program\ Files    # windows: переход в C/:Program Files`

`cd .                    # текущая директория`

`cd ..                   # переход к родительской папке`

`cd ~                    # домашняя директория`

`cd -                    # переход к последней рабочей папке`

## Создание папок и файлов

`mkdir project                        # создать папку с именем «project»`

`mkdir project project/css project/js # создать несколько папок`

`mkdir -p project/{css,js}            # то же, что выше`

`touch index.html                     # создать файл`

`touch index.html css/style.css js/script.js # создать файлы (папки css/ и js/ должны уже существовать)`

Чтобы не набирать имя папки целиком, наберите первые пару символов и нажмите **Tab** — произойдет автодополнение (если нет двух папок, начинающихся с введенных символов, иначе будут показаны сами эти папки). Справедливо для любой команды.

## Копирование файлов

`cp index.html catalog.html # копирование файла index.html в тот же каталог с переименованием в catalog.html`

`cp index.html old/         # копирование файла index.html в папку old/ (все произойдет в текущей папке)`

`cp temp/ temp2/ -r         # дублирование каталога`

## Переименование или перемещение файлов

`mv index.html old              # перемещение файла в папку`

`mv index.html old/new_name.txt # перемещение файла в папку с переименованием файла`

`mv order.txt orderNew.txt      # переименовать файл`

## Удаление папок и файлов

`rm ghost.png             # удалить файл`

`rm -rf old               # удалить папку и всё из нее`


# Алиасы

Для команд можно создавать алиасы (синонимы). Для этого в папке пользователя (OSX и linux) или в **C:/Users/ИМЯ_ПОЛЬЗОВАТЕЛЯ/.bashrc (Windows)** нужно вписать строки, наподобие **alias pro='cd /d/projects'** (одна строка в файле — один алиас)..

`alias                 # отобразит алиасы, которые уже заданы в системе`

`c='clear'       # создаст алиас который будет очищать консоль`

`unalias c             # удалит алиас " c "`

`unalias -a            # удалит все записанные алиасы`

## Разное

Подборка команд, показывающих бОльшую скорость работы с консолью, чем с GUI или просто удобных команд. Многие из них могут быть реализованы различными путями с GUI, что ничуть не умаляет удобства консоли.

`clear                 # очистить консоль`

`df -h                 # показать статистику использования пространства на дисках`

`grep -i -n --color 'carousel' index.html css/style.css # найти слово carousel в двух указанных файлах (с игнором регистра), вывести строки с этим словом и номера строк (искомое слово подсветить)`

`grep word -r project  # найти слово word во всех файлах в папке project`

`find . -iname '*ind*' # найти в текущей папке (и подпапках) все файлы, имена которых содержат ind и показать списком`

`ls -a >> file.txt     # записать в file.txt результат вывода команды ls -a`

`ls src/less/mixins    # показать содержимое папки с указанным путем без перехода в неё`

`echo  "Some text"     # вывод текста в консоль`

`chmod +x ./fileName   # сделать файл исполняемым`

`whoami                # выводит имя пользователя`

## Использование переменных

Переменные позволяют хранить в файле сценария информацию, например — результаты работы команд для использования их другими командами.

Существуют два типа переменных, которые можно использовать в bash-скриптах:

1. Переменные среды - переменные установленые в среде

`echo $HOME`

`echo "Env variable $HOME"`

2. Пользовательские переменные - хранят значение до тех пор, пока не завершится выполнение сценария.

`#!/bin/zsh`

`grade=5`

`person="Adam"`

`echo "$person is a good boy, he is in grade $grade"`

## Подстановка команд в переменные

Одна из самых полезных возможностей bash-скриптов — это **возможность извлекать информацию из вывода команд и назначать её переменным**, что позволяет использовать эту информацию где угодно в файле сценария.

Сделать это можно двумя способами.

1. С помощью значка обратного апострофа «`»

`mydir=`pwd``


2. С помощью конструкции $()

`mydir=$(pwd)`

А скрипт, в итоге, может выглядеть так:

`#!/bin/bash`

`mydir=$(pwd)`

`echo $mydir`

В ходе его работы вывод команды **pwd** будет сохранён в переменной **mydir**, содержимое которой, с помощью команды **echo**, попадёт в консоль.

# Математические операции

Для выполнения математических операций в файле скрипта можно использовать конструкцию вида **$((a+b))**

`#!/bin/bash`


`var1=$(( 5 + 5 ))`

`echo $var1`


`var2=$(( $var1 * 2 ))`

`echo $var2`

# Управляющая конструкция if-then

В некоторых сценариях требуется управлять потоком исполнения команд. Например, если некое значение больше пяти, нужно выполнить одно действие, в противном случае — другое. Подобное применимо в очень многих ситуациях, и здесь нам поможет управляющая конструкция if-then. В наиболее простом виде она выглядит так

`if команда`

`then`

`команды`

`fi` 

`#!/bin/bash`

`if pwd`

`then`

`echo "It works"`

`fi`

Пример: надо найти некоего пользователя в **/etc/passwd**, и если найти его удалось, сообщить о том, что он существует.

`#!/bin/bash`

`user=likegeeks`

`if grep $user /etc/passwd`

`then`

`echo "The user $user Exists"`

`fi`

# Управляющая конструкция if-then-else

Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией **if-then-else**. Вот как она устроена:

`#!/bin/bash`

`user=anotherUser`

`if grep $user /etc/passwd`

`then`

`echo "The user $user Exists"`

`else`

`echo "The user $user doesn’t exist"`

`fi`

# Конструкция CASE

Если вы столкнулись с парой различных возможных действий, то использование оператора **case** может быть более полезным, чем вложенные операторы **if**. Для более сложных условий используйте пример, как показано ниже

`case "$extension" in`

  `"jpg"|"jpeg") echo "It's image with jpeg extension." ;;`

 `"png")        echo "It's image with png extension."  ;;`

  `"gif")        echo "Oh, it's a giphy!"               ;;`

 `*)            echo "Woops! It's not image!"          ;;`
 
`esac`




















