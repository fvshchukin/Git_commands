# Шпаргалка по консольным командам Git

## Общее

Git — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). **Важно:** добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (git add), потом «сохраняем» (git commit).

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые, изменённые, проиндексированные (готовые к коммиту).

### Ключ к пониманию

Ключ к пониманию концепции git — знание о «трех деревьях»:

- Рабочая директория — файловая система проекта (те файлы, с которыми вы работаете).

* Индекс — список отслеживаемых git-ом файлов и директорий, промежуточное хранилище изменений (редактирование, удаление отслеживаемых файлов).

+ Директория .git/ — все данные контроля версий этого проекта (вся история разработки: коммиты, ветки, теги и пр.).

**Коммит** — «сохранение» (хранит набор изменений, сделанный в рабочей директории с момента предыдущего коммита). Коммит неизменен, его нельзя отредактировать.

У всех коммитов (кроме самого первого) есть один или более родительских коммитов, поскольку коммиты хранят изменения от предыдущих состояний.

### Простейший цикл работ:

* Редактирование, добавление, удаление файлов (собственно, работа).
* Индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).
* Коммит (фиксация изменений).
* Возврат к шагу 1 или отход ко сну.

### Указатели:
- **HEAD** — указатель на текущий коммит или на текущую ветку (то есть, в любом случае, на коммит). Указывает на родителя коммита, который будет создан следующим.
- **ORIG_HEAD** — указатель на коммит, с которого вы только что переместили HEAD (командой git reset ..., например).
- **Ветка** (master, develop etc.) — указатель на коммит. При добавлении коммита, указатель ветки перемещается с родительского коммита на новый.
- **Теги** — простые указатели на коммиты. Не перемещаются.

## Настройки

**Перед началом работы нужно выполнить некоторые настройки:**

*`git config --global user.name "Your Name" # указать имя, которым будут подписаны коммиты`*

*`git config --global user.email "e@w.com"  # указать электропочту, которая будет в описании коммитера`*

*`git config --global core.autocrlf true # Включит в преобразование окончаний строк из CRLF в LF`*

**И**

*`git config --global core.safecrlf true`*

*`git config -global core.editor vim (nano, code, pstorm, и т.д.)`*

## Указание неотслеживаемых файлов

Файлы и директории, которые не нужно включать в репозиторий, указываются в файле **.gitignore**. Обычно это устанавливаемые зависимости **(node_modules/, bower_components/)**, готовая сборка **build/** или **dist/** и подобные, создаваемые при установке или запуске. Каждый файл или директория указываются с новой строки, возможно использование шаблонов.

# Шпаргалка по bash

## Суть

**Консоль** — удобный и быстрый инструмент управления компьютером. Вводим команду текстом, получаем результат или сообщение об ошибке с указанием в чём ошибка.

Работая с консолью, мы всегда «находимся» в какой-то папке (это указано в строке над курсором). Если там написано **~**, то мы в папке пользователя (зависит от настроек Windows, чаще всего это **C:/Users/ВАШЕИМЯПОЛЬЗОВАТЕЛЯ/)**, если там **/d/projects**, мы в папке **D:/projects.**

## Файловая система

### Просмотр содержимого папки

`pwd                     # выводит текущи путь (сокращение от PRINT WORK DIRECTORY)`

`ls                      # показать содержимое папки`

`ls -l                   # отображает расширенную информацию о файлах и папках`

`ls -a                   # то же, но показывать и скрытые файлы и папки`

`ls -a -1                # то же, но в один столбец`

`ls -hF -1 --sort=extension # показать содержимое папки «красиво, в один столбец»`

`ls build/css            # показать содержимое папки ТЕКУЩАЯ_ПАПКА/build/css`

`ls /d/projects          # показать содержимое папки D:/projects`


## Перемещение по файловой системе

*Пользователь всегда находится в какой-то папке, она (или полный путь) всегда показана до области ввода команд.*

`cd projects             # переход в папку projects, которая есть текущей папке`

`cd /d/projects          # windows: переход в папку projects, расположенную по адресу D:/projects`

`cd /c/Program\ Files    # windows: переход в C/:Program Files`

`cd .                    # текущая директория`

`cd ..                   # переход к родительской папке`

`cd ~                    # домашняя директория`

`cd -                    # переход к последней рабочей папке`

## Создание папок и файлов

`mkdir project                        # создать папку с именем «project»`

`mkdir project project/css project/js # создать несколько папок`

`mkdir -p project/{css,js}            # то же, что выше`

`touch index.html                     # создать файл`

`touch index.html css/style.css js/script.js # создать файлы (папки css/ и js/ должны уже существовать)`

Чтобы не набирать имя папки целиком, наберите первые пару символов и нажмите **Tab** — произойдет автодополнение (если нет двух папок, начинающихся с введенных символов, иначе будут показаны сами эти папки). Справедливо для любой команды.

## Копирование файлов

`cp index.html catalog.html # копирование файла index.html в тот же каталог с переименованием в catalog.html`

`cp index.html old/         # копирование файла index.html в папку old/ (все произойдет в текущей папке)`

`cp temp/ temp2/ -r         # дублирование каталога`

## Переименование или перемещение файлов

`mv index.html old              # перемещение файла в папку`

`mv index.html old/new_name.txt # перемещение файла в папку с переименованием файла`

`mv order.txt orderNew.txt      # переименовать файл`

## Удаление папок и файлов

`rm ghost.png             # удалить файл`

`rm -rf old               # удалить папку и всё из нее`


# Алиасы

Для команд можно создавать алиасы (синонимы). Для этого в папке пользователя (OSX и linux) или в **C:/Users/ИМЯ_ПОЛЬЗОВАТЕЛЯ/.bashrc (Windows)** нужно вписать строки, наподобие **alias pro='cd /d/projects'** (одна строка в файле — один алиас)..

`alias                 # отобразит алиасы, которые уже заданы в системе`

`c='clear'       # создаст алиас который будет очищать консоль`

`unalias c             # удалит алиас " c "`

`unalias -a            # удалит все записанные алиасы`

## Разное

Подборка команд, показывающих бОльшую скорость работы с консолью, чем с GUI или просто удобных команд. Многие из них могут быть реализованы различными путями с GUI, что ничуть не умаляет удобства консоли.

`clear                 # очистить консоль`

`df -h                 # показать статистику использования пространства на дисках`

`grep -i -n --color 'carousel' index.html css/style.css # найти слово carousel в двух указанных файлах (с игнором регистра), вывести строки с этим словом и номера строк (искомое слово подсветить)`

`grep word -r project  # найти слово word во всех файлах в папке project`

`find . -iname '*ind*' # найти в текущей папке (и подпапках) все файлы, имена которых содержат ind и показать списком`

`ls -a >> file.txt     # записать в file.txt результат вывода команды ls -a`

`ls src/less/mixins    # показать содержимое папки с указанным путем без перехода в неё`

`echo  "Some text"     # вывод текста в консоль`

`chmod +x ./fileName   # сделать файл исполняемым`

`whoami                # выводит имя пользователя`

## Использование переменных

Переменные позволяют хранить в файле сценария информацию, например — результаты работы команд для использования их другими командами.

Существуют два типа переменных, которые можно использовать в bash-скриптах:

1. Переменные среды - переменные установленые в среде

`echo $HOME`

`echo "Env variable $HOME"`

2. Пользовательские переменные - хранят значение до тех пор, пока не завершится выполнение сценария.

`#!/bin/zsh`

`grade=5`

`person="Adam"`

`echo "$person is a good boy, he is in grade $grade"`

## Подстановка команд в переменные

Одна из самых полезных возможностей bash-скриптов — это **возможность извлекать информацию из вывода команд и назначать её переменным**, что позволяет использовать эту информацию где угодно в файле сценария.

Сделать это можно двумя способами.

1. С помощью значка обратного апострофа «`»

`mydir=`pwd``


2. С помощью конструкции $()

`mydir=$(pwd)`

А скрипт, в итоге, может выглядеть так:

`#!/bin/bash`

`mydir=$(pwd)`

`echo $mydir`

В ходе его работы вывод команды **pwd** будет сохранён в переменной **mydir**, содержимое которой, с помощью команды **echo**, попадёт в консоль.

# Математические операции

Для выполнения математических операций в файле скрипта можно использовать конструкцию вида **$((a+b))**

`#!/bin/bash`


`var1=$(( 5 + 5 ))`

`echo $var1`


`var2=$(( $var1 * 2 ))`

`echo $var2`

# Управляющая конструкция if-then

В некоторых сценариях требуется управлять потоком исполнения команд. Например, если некое значение больше пяти, нужно выполнить одно действие, в противном случае — другое. Подобное применимо в очень многих ситуациях, и здесь нам поможет управляющая конструкция if-then. В наиболее простом виде она выглядит так

`if команда`

`then`

`команды`

`fi` 

`#!/bin/bash`

`if pwd`

`then`

`echo "It works"`

`fi`

Пример: надо найти некоего пользователя в **/etc/passwd**, и если найти его удалось, сообщить о том, что он существует.

`#!/bin/bash`

`user=likegeeks`

`if grep $user /etc/passwd`

`then`

`echo "The user $user Exists"`

`fi`

# Управляющая конструкция if-then-else

Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией **if-then-else**. Вот как она устроена:

`#!/bin/bash`

`user=anotherUser`

`if grep $user /etc/passwd`

`then`

`echo "The user $user Exists"`

`else`

`echo "The user $user doesn’t exist"`

`fi`

# Конструкция CASE

Если вы столкнулись с парой различных возможных действий, то использование оператора **case** может быть более полезным, чем вложенные операторы **if**. Для более сложных условий используйте пример, как показано ниже

`case "$extension" in`

  `"jpg"|"jpeg") echo "It's image with jpeg extension." ;;`

 `"png")        echo "It's image with png extension."  ;;`

  `"gif")        echo "Oh, it's a giphy!"               ;;`

 `*)            echo "Woops! It's not image!"          ;;`

`esac`

# Циклы

В **Bash** есть четыре типа циклов: **for, while, until и select**.

+ **FOR**

`# 1`

`for arg in elem1 elem2 ... elemN`

`do`

  `# statements`

`done`

`# 2`

`for i in {1..5}; do echo $i; done`

`# 3`

`for (( i = 0; i < 10; i++ )); do`

  `echo $i`

`done``

`# 4`

`for FILE in $HOME/*.bash; do`

  `mv "$FILE" "${HOME}/scripts"`

  `chmod +x "${HOME}/scripts/${FILE}"`

`done`

* **WHILE** - Цикл **while** проверяет условие и перебирает последовательность команд, пока это условие истинно. Условие - это не что иное, как первичное значение, используемое в условиях **if..then**.

`while [[ condition ]]`

`do`

  `# statements`

`done`

`# Squares of numbers from 0 through 9`

`x=0`

`while [[ $x -lt 10 ]]; do # value of x is less than 10`

  `echo $(( x * x ))`

  `x=$(( x + 1 )) # increase x`

`done`

- **UNTIL** - Цикл **until** - полная противоположность цикла **while**. Какое-то время он проверяет условие теста, но продолжает цикл, пока это условие ложно

`until [[ condition ]]; do`

  `#statements`

`done`

В этом примере пользователю задается вопрос, какой диспетчер пакетов он хотел бы использовать. Затем он спросит, какой пакет мы хотим установить, и, наконец, приступит к его установке.

`PS3="Choose the package manager: "`

`select ITEM in bower npm gem pip`

`do`

  `echo -n "Enter the package name: " && read PACKAGE`

  `case $ITEM in`

    `bower) bower install $PACKAGE ;;`

    `npm)   npm   install $PACKAGE ;;`

    `gem)   gem   install $PACKAGE ;;`

    `pip)   pip   install $PACKAGE ;;`

  `esac`

  `break # avoid infinite loop`

`done`

* **LOOP CONTROL**- Бывают ситуации, когда нам нужно остановить цикл до его нормального завершения или перешагнуть через итерацию. В этих случаях мы можем использовать встроенные в оболочку операторы break и continue.

Оператор *break* используется для выхода из текущего цикла до его завершения Оператор continue проходит одну итерацию

`for (( i = 0; i < 10; i++ )); do`

  `if [[ $(( i % 2 )) -eq 0 ]]; then continue; fi`

  `echo $i`

`done`

# Сравнение чисел

Сравнения пишем в [ ] обязательно пробелы в скобках

`# eq - equal`

`# ge - greater equal`

`# gt - greater than`

`# le - less equal`

`# lt - less than

`# ne - not equal`  

`n1 -eq n2 # Возвращает истинное значение, если n1 равно n2.`

`n1 -ge n2 # Возвращает истинное значение, если n1 больше или равно n2.`

`n1 -gt n2 # Возвращает истинное значение, если n1 больше n2.`

`n1 -le n2 # Возвращает истинное значение, если n1 меньше или равно n2.`

`n1 -lt n2 # Возвращает истинное значение, если n1 меньше n2.`

`n1 -ne n2 # Возвращает истинное значение, если n1 не равно n2.`


`val1=6`

`if [ $val1 -gt 5 ]`

`then`

`echo "The test value $val1 is greater than 5"`

`else`

`echo "The test value $val1 is not greater than 5"`

`fi`

# Сравнение строк

В сценариях можно сравнивать и строковые значения.
Операторы сравнения выглядят довольно просто, однако у операций сравнения строк есть определённые особенности, которых мы коснёмся ниже. Вот список операторов.

`str1 = str2   # Проверяет строки на равенство, возвращает истину, если строки идентичны.`

`str1 != str2  # Возвращает истину, если строки не идентичны.`

`# операторы «>» и «<» необходимо экранировать с помощью обратной косой черты,`

`str1 \< str2   # Возвращает истину, если str1 меньше, чем str2.`

`str1 \> str2   # Возвращает истину, если str1 больше, чем str2.`

`-n str1       # Возвращает истину, если длина str1 больше нуля.`

`-z str1       # Возвращает истину, если длина str1 равна нулю.`


`#!/bin/bash`

`user ="likegeeks"`

`if [ $user = $USER ]`

`then`

`echo "The user $user  is the current logged in user"`

`fi`

# Проверки файлов

Kоманды позволяют проверять различные условия, касающиеся файлов

`-d file         # Проверяет, существует ли файл, и является ли он директорией.`

`-e file         # Проверяет, существует ли файл.`

`-f file         # Проверяет, существует ли файл, и является ли он файлом.`

`-r file         # Проверяет, существует ли файл, и доступен ли он для чтения.`

`-s file         # Проверяет, существует ли файл, и не является ли он пустым.`

`-w file         # Проверяет, существует ли файл, и доступен ли он для записи.`

`-x file         # Проверяет, существует ли файл, и является ли он исполняемым.`

`file1 -nt file2 # Проверяет, новее ли file1, чем file2.`

`file1 -ot file2 # Проверяет, старше ли file1, чем file2.`

`-O file         # Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.`

`-G file         # Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.`


`#!/bin/bash`

`mydir=/home/likegeeks`

`if [ -d $mydir ]                    # если файл сущетсвует и он является директорией`

`then`

`echo "The $mydir directory exists"  # выводим сообщение`

`cd $mydir                          # переходим в него`

`ls                                  # отображаем содержимое`

`else                                # ИНАЧЕ`

`echo "The $mydir directory does not exist"`

`fi`

# Операторы

Пайпы | - передает результат выполненной инструкции следующему пайпу

`# command1 | command2 | command3`

`ls -l | grep .md$ | less`

Точка с запятой ; - выполняет команды последовательно

`# command2 will be executed after command1`

`command1 ; command2`

Амперсанд **&** - оболочка выполняет команду асинхронно в подоболочке. Другими словами, эта команда будет выполняться в фоновом режиме

Двойной амперсанд (И) **&&** - вторая команды будет выполнена только в случае УСПЕШНОГО заверения первой команды

`# command2 will be executed if, and only if, command1 finishes successfully (returns 0 exit status)
command1 && command2`

Двойной пайп (ИЛИ) - вторая команды будет выполнена только в случае НЕУДАЧНОГО заверения первой команды

`# command2 will be executed if, and only if, command1 finishes unsuccessfully (returns code of error)
command1 || command2`

Тестовые [ ] - Эти выражения помогают нам указать результаты условного выражения. Используются обычно в блоках **if**

`# Single-line`

`if [[ 1 -eq 1 ]]; then echo "true"; fi`

`# Multi-line`

`if [[ 1 -eq 1 ]]; then`

  `echo "true"`

`fi`


`# Single-line`

`if [[ 2 -ne 1 ]]; then echo "true"; else echo "false"; fi`


`# Multi-line

`if [[ 2 -ne 1 ]]; then`

  `echo "true"`

`else`

  `echo "false"`

`fi`

## Длинный вывод в консоли: Vim

Вызов некоторых консольных команд приводит к необходимости очень длинного вывода в консоль (пример: вывод истории всех изменений в файле командой `**git log -p fileName.txt)**`. При этом прямо в консоли запускается редактор **Vim**. Он работает в нескольких режимах, из которых Вас заинтересуют режим вставки (редактирование текста) и нормальный (командный) режим. Чтобы попасть из **Vim** обратно в консоль, нужно в командном режиме ввести **:q**. Переход в командный режим из любого другого: **Esc**.

Если нужно что-то написать, нажмите **i** — это переход в режим вставки текста. Если нужно сохранить изменения, перейдите в командный режим и наберите **:w**.

# Vim (некоторые команды)

`# Нажатия кнопок`

`ESC     — переход в командный режим`

`i       — переход в режим редактирования текста`

`ZQ (зажат Shift, поочередное нажатие) — выход без сохранения`

`ZZ (зажат Shift, поочередное нажатие) — сохранить и выйти`

````bash`


`# Нажатия кнопок`

`ESC     — переход в командный режим`

`i       — переход в режим редактирования текста`

`ZQ (зажат Shift, поочередное нажатие) — выход без сохранения`

`ZZ (зажат Shift, поочередное нажатие) — сохранить и выйти`


`# Ввод в командном режиме`

`:q!             — выйти без сохранения`

`:wq             — сохранить файл и выйти`

`:w filename.txt — сохранить файл как filename.txt`

## Консольные команды

Создать новый репозиторий

`git init             # создать новый проект в текущей директории`

`git init folder-name # создать новый проект в указанной директории`

## Клонирование репозитория

`# клонировать удаленный репозиторий в одноименную директорию`

`git clone https://github.com/cyberspacedk/Git-commands.git`    

`# клонировать удаленный репозиторий в директорию «FolderName»`

`git clone https://github.com/cyberspacedk/Git-commands.git FolderName` 

`# клонировать репозиторий в текущую директорию`

`git clone https://github.com:nicothin/web-design.git .`

## Просмотр изменений

`git status              # показать состояние репозитория
 (отслеживаемые, изменённые, новые файлы и пр.)`

`git diff                # сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)`

`git diff --color-words  # сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)`

`git diff index.html     # сравнить файл из рабочей директории и индекс`

`git diff HEAD           # сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)`

`git diff --staged       # сравнить индекс и коммит с HEAD`

`git diff master feature # посмотреть что сделано в ветке feature по сравнению с веткой master`

`git diff --name-only master feature # посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов`

`git diff master...feature # посмотреть что сделано в ветке feature с момента (коммита) расхождения с master`

## Добавление изменений в индекс

`git add .        # добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий`

`git add text.txt # добавить в индекс указанный файл (был изменён, был удалён или это новый файл)`

`git add -i       # запустить интерактивную оболочку для добавления в индекс только выбранных файлов`

`git add -p       # показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании`

## Удаление изменений из индекса

`git reset            # убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), антипод git add`

`git reset readme.txt # убрать из индекса изменения указанного файла (в рабочей директории изменения сохранятся)`

## Отмена изменений

`git checkout text.txt      # ОПАСНО: отменить изменения в файле, вернуть состояние файла, имеющееся в индексе`

`git reset --hard           # ОПАСНО: отменить изменения; вернуть то, что в коммите, на который указывает HEAD (незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)`

`git clean -df              # удалить неотслеживаемые файлы и директории`


## Коммиты

`git commit -m "Name of commit"    # зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение`

`git commit -a -m "Name of commit" # проиндексировать отслеживаемые файлы (ТОЛЬКО отслеживаемые, но НЕ новые файлы) и закоммитить, добавить сообщение`


## Отмена коммитов и перемещение по истории

Все коммиты, которые уже были отправлены в удалённый репозиторий, должны отменяться новыми коммитами **(git revert)**, дабы избежать проблем с историей разработки у других участников проекта.

`git revert HEAD --no-edit    # создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения`

`git revert b9533bb --no-edit # то же, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)`

**Все команды, приведённые ниже можно выполнять ТОЛЬКО если коммиты еще не были отправлены в удалённый репозиторий.**

`# ВНИМАНИЕ! Опасные команды, можно потерять незакоммиченные изменения`

`git commit --amend -m "Название"  # «перекоммитить» изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными из «отменяемого» коммита, но новым сообщением)`

`git reset --hard @~      # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита`

`git reset --hard 75e2d51 # передвинуть HEAD (и ветку) на коммит с указанным хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита`

`git reset --soft @~      # передвинуть HEAD (и ветку) на предыдущий коммит, но в рабочей директории и индексе оставить все изменения`

`git reset --soft @~2     # то же, но передвинуть HEAD (и ветку) на 2 коммита назад`

`git reset @~             # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию оставить как есть, индекс сделать таким, каким он был в момент предыдущего коммита (удобнее, чем git reset --soft @~, если индекс нужно задать заново)`

`# Почти как git reset --hard, но безопаснее: не получится потерять изменения в рабочей директории`

`git reset --keep @~      # передвинуть HEAD (и ветку) на предыдущий коммит, сбросить индекс, но в рабочей директории оставить изменения, если возможно (если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдёт)`

## Временно переключиться на другой коммит

`git checkout b9533bb # переключиться на коммит с указанным хешем (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита)`

`git checkout master  # переключиться на коммит, на который указывает master (переместить HEAD на коммит, на который указывает master, рабочую директорию вернуть к состоянию на момент этого коммита)`

## Переключиться на другой коммит и продолжить работу с него

Потребуется создание новой ветки, начинающейся с указанного коммита.

`git checkout -b new-branch 5589877   # создать ветку new-branch, начинающуюся с коммита c хешем 5589877 (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита, создать указатель на этот коммит (ветку) с указанным именем)`

## Восстановление изменений

`git checkout 5589877 index.html  # восстановить в рабочей директории указанный файл на момент указанного коммита (и добавить это изменение в индекс) (git reset index.html для удаления из индекса, но сохранения изменений в файле)`

## Копирование коммита (перенос коммитов)

`git cherry-pick 5589877          # скопировать на активную ветку изменения из указанного коммита, закоммитить эти изменения`

`git cherry-pick master~2..master # скопировать на активную ветку изменения из master (2 последних коммита)`

`git cherry-pick -n 5589877       # скопировать на активную ветку изменения из указанного коммита, но НЕ КОММИТИТЬ (подразумевается, что мы сами потом закоммитим)`

`git cherry-pick master..feature  # скопировать на активную ветку изменения из всех коммитов ветки feature с момента её расхождения с master (похоже на слияние веток, но это копирование изменений, а не слияние), закоммитить эти изменения; это может вызвать конфликт`

`git cherry-pick --abort    # прервать конфликтный перенос коммитов`

`git cherry-pick --continue # продолжить конфликтный перенос коммитов (сработает только после решения конфликта)`

## История коммитов

Выход из длинного лога вывода: **q**.

`git log master             # показать коммиты в указанной ветке`

`git log -2                 # показать последние 2 коммита в активной ветке`

`git log -2 --stat          # показать последние 2 коммита и статистику внесенных ими изменений`

`git log -p -22             # показать последние 22 коммита и внесенную ими разницу на уровне строк`

`git log --graph -10        # показать последние 10 коммитов с ASCII-представлением ветвления`

`git log --since=2.weeks    # показать коммиты за последние 2 недели`

`git log --after '2018-06-30' # показать коммиты, сделанные после указанной даты`

`git log index.html         # показать историю изменений файла index.html (только коммиты)`

`git log -5 index.html      # показать историю изменений файла index.html, последние 5 коммитов (только коммиты)`

`git log -p index.html      # показать историю изменений файла index.html (коммиты и изменения)`

`git log -G'myFunction' -p  # показать все коммиты, в которых менялись строки с myFunction (в кавычках регулярное выражение)`

`git log -L '/<head>/','/<\/head>/':index.html # показать изменения от указанного до указанного регулярных выражений в указанном файле`

`git log --grep fix         # показать коммиты, в описании которых есть буквосочетание fix (регистрозависимо, только коммиты текущей ветки)`

`git log --grep fix -i      # показать коммиты, в описании которых есть буквосочетание fix (регистроНЕзависимо, только коммиты текущей ветки)`

`git log --grep 'fix(ing|me)' -P # показать коммиты, в описании которых есть совпадения для регулярного выражения (только коммиты текущей ветки)`

`git log --pretty=format:"%h - %an, %ar : %s" -4 # показать последние 4 коммита с форматированием выводимых данных`

`git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short # мой формат вывода, висящий на алиасе оболочки`

`git log master..branch_99  # показать коммиты из ветки branch_99, которые не влиты в master`

`git log branch_99..master  # показать коммиты из ветки master, которые не влиты в branch_99`

`git log master...branch_99 --boundary -- graph # показать коммиты из указанных веток, начиная с их расхождения (коммит расхождения будет показан)`


`git show 60d6582           # показать изменения из коммита с указанным хешем`

`git show HEAD~             # показать данные о предыдущем коммите в активной ветке`

`git show @~                # аналогично предыдущему`

`git show HEAD~3            # показать данные о коммите, который был 3 коммита назад`

`git show my_branch~2       # показать данные о коммите, который был 2 коммита назад в указанной ветке`

`git show @~:index.html     # показать контент указанного файла на момент предыдущего (от HEAD) коммита`

`git show :/"подвал"        # показать самый новый коммит, в описании которого есть указанное слово (из любой ветки)`


## Удаление файла

`git rm text.txt    # удалить отслеживаемый неизменённый файл и проиндексировать это изменение`

`git rm -f text.txt # удалить отслеживаемый изменённый файл и проиндексировать это изменение`

`git rm -r log/     # удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение`

`git rm ind*        # удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение`

`git rm --cached readme.txt # удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)`

## Перемещение/переименование файлов

Для **git** не существует переименования. Переименование воспринимается как удаление старого файла и создание нового. Факт переименования может быть определен только после индексации изменения.

`git mv text.txt test_new.txt # переименовать файл «text.txt» в «test_new.txt» и проиндексировать это изменение`

`git mv readme_new.md folder/ # переместить файл readme_new.md в директорию folder/ (должна существовать) и проиндексировать это изменение`


## Кто написал строку

`git blame README.md --date=short -L 5,8 # показать строки 5-8 указанного файла и коммиты, в которых строки были добавлены`

## История изменений указателей (веток, HEAD)

`git reflog -20             # показать последние 20 изменений положения указателя HEAD`

`git reflog --format='%C(auto)%h %<|(20)%gd %C(blue)%cr%C(reset) %gs (%s)' -20 # то же, но с указанием давности действий`


## Ветки

`git branch                 # показать список веток`

`git branch -v              # показать список веток и последний коммит в каждой`

`git branch new_branch      # создать новую ветку с указанным именем на текущем коммите`

`git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите`

`git branch -f master 5589877  # переместить ветку master на указанный коммит`

`git branch -f master master~2 # переместить ветку master на 2 коммита назад`

`git checkout new_branch    # перейти в указанную ветку`

`git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё`

`git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё`

`git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix`

`git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)`

`git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов`

`git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния`

`git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)`

`git branch --merged        # показать ветки, уже слитые с активной`

`git branch --no-merged     # показать ветки, не слитые с активной`

`git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)`

`git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name`

`git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name`

`git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории`

`git branch --unset-upstream # завершить процесс переименования`


## Теги

`git tag v1.0.0               # создать тег с указанным именем на коммите, на который указывает HEAD`

`git tag -a -m 'В продакшен!' v1.0.1 master # создать тег с описанием на том коммите, на который смотрит ветка master`

`git tag -d v1.0.0            # удалить тег с указанным именем(ами)`

`git tag -n                   # показать все теги, и по 1 строке сообщения коммитов, на которые они указывают`

`git tag -n -l 'v1.*'         # показать все теги, которые начинаются с 'v1.*'`

## Временное сохранение изменений без коммита

`git stash     # временно сохранить незакоммиченные изменения и убрать их из рабочей директории`

`git stash pop # вернуть сохраненные командой git stash изменения в рабочую директорию`

## Удалённые репозитории

Есть два распространённых способа привязать удалённый репозиторий к локальному: по **HTTPS** и по **SSH**. Если **SSH** у вас не настроен (или вы не знаете что это), привязывайте удалённый репозиторий по **HTTPS** (адрес привязываемого репозитория должен начинаться с **https://)**.

`git remote -v              # показать список удалённых репозиториев, связанных с локальным`

`git branch -r              # показать удаленные ветки`

`git branch -a              # показать все ветки(локальные и удаленные)`

`git remote remove origin   # убрать привязку удалённого репозитория с сокр. именем origin`

`git remote add origin https://github.com:nicothin/test.git # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL`

`git remote rm origin       # удалить привязку удалённого репозитория`

`git remote show origin     # получить данные об удалённом репозитории с сокращенным именем origin`

`git fetch origin           # скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками`

`git fetch origin master    # то же, но скачивается только указанная ветка`

`git checkout --track origin/github_branch # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё`

`git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master`

`git pull origin            # влить изменения с удалённого репозитория (все ветки)`

`git pull origin master     # влить изменения с удалённого репозитория (только указанная ветка)`

## Конфликт слияния

Предполагается ситуация: есть ветка **master** и есть ветка **feature**. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку **master** пытаемся влить ветку **feature** (**git merge feature**), получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле **index.html**.

При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.

`git merge feature                # влить в активную ветку изменения из ветки feature`

`git merge-base master feature    # показать хеш последнего общего коммита для двух указанных веток`

`git checkout --ours index.html   # оставить в конфликтном файле (index.html) состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки master)`

`git checkout --theirs index.html # оставить в конфликтном файле (index.html) состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)`

`git checkout --merge index.html  # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)`

`git checkout --conflict=diff3  --merge index.html # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки`

`git reset --hard  # прекратить это прерванное слияние, вернуть рабочую директорию и индекс как было в момент коммита, на который указывает HEAD, а я пойду немного поплачу`

`git reset --merge # прекратить это прерванное слияние, но оставить изменения, не закоммиченные до слияния (для случая, когда слияние делается не на чистом статусе)`

`git reset --abort # то же, что и строкой выше`



## «Перенос» ветки

Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, внесённые в основной ветке (уже после ответвления переносимой).

Нельзя «переносить» ветку, если она уже отправлена на удалённый репозиторий.

`git rebase master # перенести все коммиты (создать их копии) активной ветки так, будто активная ветка ответвилась от master на нынешней вершине master (часто вызывает конфликты)`

`git rebase --onto master feature # перенести коммиты активной ветки на master, начиная с того места, в котором активная ветка отделилась от ветки feature`

`git rebase --abort # прервать конфликтный rebase, вернуть рабочую директорию и индекс к состоянию до начала rebase`

`git rebase --continue # продолжить конфликтный rebase (сработает только после разрешения конфликта и индексации такого разрешения)`

### Как отменить rebase

`git reflog feature -2        # смотрим лог перемещений ветки, которой делали rebase (в этом примере — feature), видим последний коммит ПЕРЕД rebase, на него и нужно перенести указатель ветки`

`git reset --hard feature@{1} # переместить указатель ветки feature на один коммит назад, обновить рабочую директорию и индекс`


## Разное

`git archive -o ./project.zip HEAD # создать архив с файловой структурой проекта по указанному пути (состояние репозитория, соответствующее указателю HEAD)`


## Операции с папками и файлами: создание, копирование, перемещение

## Создание файлов и директорий — touch, mkdir

Чтобы создать файл, нужно ввести в консоль команду touch (англ. «коснуться») с именем файла в качестве параметра: touch %ИМЯ_ФАЙЛА%.

`$ touch my-new-file.txt # создали файл my-new-file.txt`

Хорошей практикой при создании файла считается указывать его расширение (в примере — .txt). Это позволит операционной системе выбрать подходящую программу, чтобы открыть файл. А ещё поможет другому человеку понять, какое содержимое находится внутри.

Для создания директорий через терминал используют другую команду — mkdir (от англ. make directory — «создать директорию»).

`$ mkdir new-dir # создали директорию new-dir`

Можно создать целую структуру директорий одной командой с помощью флага -p.

`$ mkdir -p dir1/dir-inside/dir-deeper-inside`
`# создали папку dir-deeper-inside в папке dir-inside, которая находится в папке dir1`

По умолчанию touch и mkdir создают файлы и папки в текущей рабочей директории. Например, если вы находитесь в директории abs, команда touch file.txt создаст файл именно там: abs/file.txt.

Также можно использовать обе команды вместе с символом домашней директории (~) или родительской директории (..). Например, команда mkdir ~/my-git-projects создаст папку my-git-projects внутри домашней директории.

А команда touch ../../file.txt создаст файл file.txt на две папки выше по иерархии. Допустим, если вы находитесь в директории projects/git/hello, команда touch ../../file.txt создаст файл по такому пути: projects/file.txt.

## Копирование файлов — cp

Вы наверняка копировали файлы на своём компьютере через графический интерфейс — диспетчер файлов на Windows или Finder на macOS. Посмотрим, как это делать через консоль.

Для копирования файлов через терминал существует команда cp (от англ. copy — «копировать»). В простом виде cp принимает два параметра: что копируем и куда копируем.

`$ cp что_копируем куда_копируем`

`$ cp index.html src/`

`# скопировали index.html в папку src`

### Но можно указать сразу несколько файлов

`$ cp что_копируем что_копируем что_копируем куда_копируем`

`$ cp index.html style.css script.js src/`

`# скопировали три файла (index.html, style.css и script.js) в папку src`

Попробуйте вместе с нами! Откройте консоль и создайте папку first-project где угодно на компьютере. Внутри папки создайте два файла: data.txt и table.csv

`$ mkdir first-project`

`$ touch first-project/data.txt first-project/table.csv`

Эта запись равноценна поочерёдному вызову следующих команд.

`$ mkdir first-project`  
`# создали папку`

`$ touch first-project/data.txt`
`# создали первый файл`

`$ touch first-project/table.csv`
`# создали второй файл`

Теперь скопируйте файл data.txt в домашнюю директорию.

`$ cd first-project`

`# перешли в директорию`

`$ cp data.txt ~`

`# скопировали файл в домашнюю директорию`

Перейдите в домашнюю директорию ~ и посмотрите её содержимое.

`$ cd ~ # перешли в домашнюю директорию`

`$ pwd # посмотрели, где мы`
`/Users/%USER_NAME%`

`$ ls # файл скопирован, ура!`
`data.txt`
`<...>`

## Перемещение файлов и папок — mv

Копирование создаёт копию файла или папки. Но иногда вместо копии нужно удалить файл в одном месте и создать в другом. Для этого есть команда mv (от англ. move — «переместить»).

Синтаксис команды mv аналогичен синтаксису cp. После имени команды указывают список файлов и папок, которые нужно переместить, а затем — папку, в которую нужно выполнить перемещение.

Создайте папку very-important-files внутри директории first-project. Перейдите в first-project командой cd.

Затем переместите файл table.csv в папку very-important-files и проверьте результат.

`$ mv table.csv ./very-important-files`
`# сначала указываем имя файла, который хотим переместить, потом путь — куда перемещаем`

`$ cd very-important-files`
`$ ls`
`table.csv`
`# перешли в папку very-important-files и проверили, что всё сработало`

**Подберите к каждой ситуации правильную команду.**

Скопировать файлы file.txt и me.png в директорию important-files внутри домашней директории

cp file.txt me.png ~/important-files

Здесь нужна команда, название которой образовано от copy.

Переместить файлы file.txt из родительской директории и me.png из текущей директории в папку important-files в рабочей директории

mv ../file.txt me.png important-files

Здесь поможет команда, чьё название образовано от move.

Создать файл file.txt в директории important-files, которая находится на один уровень выше текущей рабочей директории, и файл me.png в текущей рабочей директории

touch ../important-files/file.txt me.png

В переводе с английского название команды означает «коснуться».

Отлично! Ещё один урок позади. Подведём итоги:

- Команда touch создаёт файл, а команда mkdir — директорию.
- С помощью флага -p можно создать целую структуру директорий одной командой: mkdir -p.
- Для копирования файлов используют команду cp, для перемещения — mv

![УР + ЛР](D:\Users\ShchukinFV\Desktop\Новая папка\Я\Верстка\ЯндексПрактикум\image/УР + ЛР)

## Операции с папками и файлами: чтение и удаление

## Чтение файлов — cat

Чтобы прочитать файл, в консоль нужно ввести cat (от англ. concatenate and print — «объединить и распечатать») вместе с именем файла. Команда распечатает то, что содержится в нём.

`$ cat myfile.txt # распечатали содержимое файла myfile.txt`
`f`ile-content-1`
`file-content-2`

## Удаление файлов и папок — rm, rmdir, rm -r

Чтобы удалить файл, нужно напечатать команду rm (от англ. remove — «удалить») и передать ей имя файла.

`$ rm example.txt # удалили файл example.txt из текущей папки`

Удалить папку можно командой rmdir (от англ. remove directory — «удалить директорию»). Не забудьте указать имя папки.

`$ rmdir images # команда удалит папку images из текущей директории,`
`# если папка images пуста`

Если в папке, которую вы пытаетесь стереть, есть какие-то файлы, то командная строка не удалит её и выведет сообщение о том, что папка не пуста (англ. Directory not empty).

Это защита от случайного удаления нужных файлов. Если папку всё-таки нужно удалить вместе со всем её содержимым, можно использовать команду **rm** так.

`$ rm -r images # удалили папку images со всем её содержимым из текущей директории`

В этом случае команда rm -r (-r — от англ. recursive, «рекурсивный») **рекурсивно** удаляет файлы и папки. Это значит, что удаление будет последовательно применяться к каждому из элементов в этой папке — пока не сотрёт их все. Затем команда удалит пустую директорию.

Например, есть папка "ФОТО", внутри которой — файлы и папка "Фотографии с дня рождения". Если вызвать команду rm -r для "ФОТО", то сначала будут удалены все файлы и папки внутри неё (в том числе папка "Фотографии с дня рождения"), а после — сама директория "ФОТО".

💡 **Будьте осторожны:** удаление объектов командами **rm и rmdir необратимо** — в этом случае файлы и папки не попадают в корзину и исчезают навсегда.

Сопоставьте задачу с подходящей для неё командой.

Прочитать файл the-best-file-ever.txt

`cat the-best-file-ever.txt`

Запомнить эту команду можно по её «кошачьему» названию.

Удалить файл the-best-file-ever.txt

`rm the-best-file-ever.txt`

Название этой команды происходит от remove.

Удалить папку screenshots

`rmdir screenshots`

Название этой команды складывается из слов remove directory.

Удалить папку screenshots и всё, что она содержит

`rm -r screenshots`

Флаг этой команды происходит от слова recursive.

## Эффективная работа с командной строкой

## Выполняйте сразу несколько команд

Команды в терминале необязательно вбивать и выполнять по очереди. Их можно указывать не по одной, а сразу списком. Для этого их нужно разделить двумя амперсандами **(&&)**.

`$ mkdir second-project && cd second-project && touch index.html style.css`
`# создаём папку second-project,`
`# переходим в папку second-project`
`# и создаём в ней два файла: index.html и style.css`

## Вызывайте команды из буфера

Допустим, вчера вы создали пять новых файлов, а сегодня решили добавить к ним ещё один, но не можете вспомнить название нужной команды. На этот случай у терминала есть собственная память. Она называется буфером (от англ. buffer — «посредник»). В буфере хранятся все команды, которые вызывались до этого. По их списку можно перемещаться.

Чтобы обратиться к последней введённой команде, нажмите на клавиатуре стрелку вверх (↑). Если нажать ещё раз, появится предпоследняя команда; ещё раз — предпредпоследняя; и так далее. Чтобы вернуться — например, от предпоследней команды к последней, — нажмите стрелку вниз (↓).

## Используйте автозаполнение

Необязательно заучивать все команды наизусть. Если нужно найти какую-нибудь из них, достаточно вспомнить, с каких букв она начинается. Можно набрать их в командной строке и дважды нажать клавишу **Tab**. Терминал покажет список всех команд, которые начинаются с этих символов.

**Tab** автоматически дописывает не только команды, но и пути. Начните печатать имя папки или файла (они должны быть в той же директории) и нажмите **Tab**. Терминал заполнит имя автоматически.

Если этого не происходит, значит, есть несколько файлов или папок, которые начинаются так же. Нажмите **Tab** ещё раз, и вы увидите их список. Терминал не знает, как ему дозаполнить такой ввод и что именно выбрать, поэтому показывает все варианты, чтобы вы могли уточнить запрос.

Рассмотрим пример. Перейдём в домашнюю директорию **/Users/Username** с помощью автозаполнения **Tab**.

`$ cd /Users/ # перешли в папку Users`

`$ cd U[Tab] # ввели первую букву имени пользователя и нажали Tab`
`# имя папки Username подставится автоматически`

`$ pwd # теперь проверим, где мы сейчас находимся`
`/Users/Username # мы в папке Username!`

Вместо того чтобы печатать полное имя папки — Username, мы набрали только его первую букву — U, нажали клавишу Tab, и консоль допечатала всё за нас.

Есть ещё один способ использовать Tab при навигации в другую директорию. Если ввести cd с названием папки, а затем нажать Tab, в консоль в качестве подсказки выведутся все возможные пути.

$ cd ~/[Tab] # вывели список директорий, чтобы понять, куда переходить

|Applications/| Downloads/| Library/| Parallels/| Public/| diagrams/| memes/| python/|
:---: :---: :---: :---: :---: :---: :---" :---:

## |Desktop/ | Dropbox/ | Movies/ | Pictures/ | bin/ | docs/ | papers/| tmp/ |

|Documents/ | Exercism/ | Music/ | Postman/ | books/ | go/ | projects/ | |

Если вывод будет слишком большой, консоль спросит, нужно ли показать все возможные варианты.

`$ cd ~/[Tab]`
`zsh: do you wish to see all 426 possibilities (429 lines)? # точно хотите увидеть все 426 варианта (429 линий)?`

Чтобы подтвердить вывод, нужно нажать y, а чтобы отменить автодополнение — n.

## Чтобы подтвердить вывод, нужно нажать y, а чтобы отменить автодополнение — n

Напомним основные:

- pwd — проверить, где мы находимся;
- ls — посмотреть список файлов/папок в директории;
- cd — перейти в выбранную папку.

С помощью этих команд можно быстро перемещаться между каталогами и изучать их содержимое.

А ещё можно почти мгновенно перемещаться в ключевые папки. Допустим, вы хотите увидеть содержимое корневой директории (англ. root directory). Это верхняя в иерархии папка, в которой хранится всё, что есть на вашем жёстком диске. Дальнейшие действия зависят от типа операционной системы. Чтобы сделать это на macOS или Linux, напечатайте в командной строке слеш (/) и дважды нажмите Tab.

Чтобы попасть в корневую директорию Windows, нужно перейти на соответствующий диск. Например, cd c:/ + Enter или cd /c + Enter.

`$ cd c:/ # переместились в корневую директорию`
`$ ls`
`Documents and Settings/     Windows/`
`Program Files/              Users/`
`Program Files (x86)/`

`# содержимое корневой директории Windows`

В домашнюю директорию можно попасть так же быстро. Вы уже знаете, как это сделать. Символ «тильда» (~) по умолчанию хранит ссылку на домашнюю директорию. Поэтому, чтобы переместиться в неё, достаточно напечатать ~ и нажать Enter.

`$ cd ~`
`$ pwd`
/Users/Username

`$ cd ~/Documents # папка Documents хранится в домашней директории`
`$ pwd`
/Users/Username/Documents

## Задание для самостоятельной работы

1. Откройте консоль и перейдите в домашнюю директорию с помощью cd ~.

2. Введите cd, нажмите пробел, а затем клавишу Tab. Если консоль сообщит, что вариантов слишком много, нажмите y. Вы должны увидеть все файлы и папки в текущей директории.

3. Введите несколько первых символов одной из папок (например, Desk), а затем ещё раз нажмите клавишу Tab — автозаполнение превратит Desk в Desktop. Выполните cd клавишей Enter.

4. Два раза нажмите на клавиатуре стрелку вверх (↑), пока не вернётесь к команде для перехода в домашнюю директорию. Дополните её выводом ls. Должно получиться следующее: `cd ~ && ls.

Если всё сделано правильно, то ваш терминал находится в домашней директории, а вы видите её содержимое на экране.# practicum

## Установка Git

Вы изучили базовые команды для работы с командной строкой. Пора установить Git! Следуйте нашим инструкциям в зависимости от типа вашей операционной системы.

## Windows

Если вы пользователь Windows, то Git у вас уже есть. Вы установили его в составе пакета Git for Windows вместе с командной строкой.

Убедитесь в этом. Откройте консоль и выполните эту команду.

`$ git version`

Если Git установлен правильно, консоль выведет его текущую версию.

### Второй способ. Используйте Homebrew

1. Установите менеджер пакетов Homebrew:

- Перейдите на [официальный сайт Homebrew](https://brew.sh/).

- Скопируйте команду для установки — справа от неё есть символ для копирования. Нажмите на него, чтобы команда попала в буфер обмена.

![Install Homerbrew](C:\Users\Федор\Desktop\Images\Install Homerbrew.png)

- Найдите программу Terminal в поиске Spotlight или в списке программ. Вставьте скопированный текст в окно терминала и нажмите Enter.

Установите Git с помощью Homebrew. Скопируйте и введите в терминал следующую команду.

`$ brew install git`

Проверьте установку, для этого откройте терминал и введите эту команду:

`$ git version`

Если на экран выводится текущая версия Git, значит, установка прошла успешно.

## Настройка Git

Для настройки Git можно использовать командную строку — теперь вы умеете работать с ней. Если у вас macOS или Linux, запустите программу Terminal. Если Windows — Git Bash.

### Работа с файлом настройки .gitconfig

Сейчас вы работаете в одиночку, но в дальнейшем вам может понадобиться использовать Git в команде. Чтобы участникам проекта было понятно, кто и какие изменения вносил, нужно представиться и указать имя пользователя и адрес электронной почты.

Вы можете указать любую электронную почту и любое имя. Сделать это можно с помощью команды git config (от англ. configuration — «конфигурация», «настройка») с ключом --global (англ. «глобальный»). При этом не имеет значения, в какой директории вы находитесь прямо сейчас: вызов git config --global сработает везде.

В качестве значения user.name нужно указать своё имя или никнейм. Для настройки параметра user.email указывают электронную почту.

`$ git config --global user.name "User Namovich"`
`# имя или ник нужно написать латиницей и в кавычках`

`$ git config --global user.email username@yandex.ru`
`# здесь нужно указать свой настоящий email`

Все глобальные настройки Git хранит в файле .gitconfig в домашней директории. Команда запишет в этот файл указанные имя и почту. Чтобы убедиться в этом, можно вызвать команду для чтения файлов.

`$ cat ~/.gitconfig`

Другой способ проверки — вывести содержимое файла конфигурации Git той же командой git config с флагом --list (англ. «список»).

`$ git config --list`

В ответ командная строка покажет текущие значения настроек.

`user.name=Username`

`user.email=username@yandex.ru`

**_Задание для самостоятельной работы_**

1. Настройте Git командами, которые мы показали в этом уроке.

`$ git config --global user.name "ваше имя или ник латиницей"`
`$ git config --global user.email ваша электронная почта`

**Убедитесь, что данные сохранились, с помощью одной из двух команд.**

`$ cat ~/.gitconfig`
`$ git config --list`

## Шпаргалка. Базовые команды в консоли

Чтобы вам было удобнее взаимодействовать с командной строкой, мы подготовили шпаргалку. В ней собраны все команды, о которых мы рассказали в уроках, и их полезные вариации.

### Навигация

- pwd (от англ. print working directory, «показать рабочую папку») — покажи, в какой я папке;
- ls (от англ. list directory contents, «отобразить содержимое директории») — покажи файлы и папки в текущей папке;
- ls -a — покажи также скрытые файлы и папки, названия которых начинаются с символа .;

- cd first-project (от англ. change directory, «сменить директорию») — перейди в папку first-project;
- cd first-project/html — перейди в папку html, которая находится в папке first-project;
- cd .. — перейди на уровень выше, в родительскую папку;
- cd ~ — перейди в домашнюю директорию (/Users/Username);
- cd / — перейди в корневую директорию.

### Работа с файлами и папками

**_Создание_**

- touch index.html (англ. touch, «коснуться») — создай файл index.html в текущей папке;
- touch index.html style.css script.js — если нужно создать сразу несколько файлов, можно напечатать их имена в одну строку через пробел;
- mkdir second-project (от англ. make directory, «создать директорию») — создай папку с именем second-project в текущей папке.

**_Копирование и перемещение_**

- cp file.txt ~/my-dir (от англ. copy, «копировать») — скопируй файл в другое место;
- mv file.txt ~/my-dir (от англ. move, «переместить») — перемести файл или папку в другое место.

**_Удаление_**

- rm about.html (от англ. remove, «удалить») — удали файл about.html;
- rmdir images (от англ. remove directory, «удалить директорию») — удали папку images;
- rm -r second-project (от англ. remove, «удалить» + recursive, «рекурсивный») — удали папку second-project и всё, что она содержит.

## Полезные возможности

- Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (&&).
- У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓).
- Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама.
- Например, вы находитесь в папке dev. Начните вводить cd first и дважды нажмите Tab. Если папка first-project есть внутри dev, командная строка автоматически подставит её имя. Останется только нажать Enter.

## О чём этот модуль

Git — это система контроля версий, которая помогает отслеживать изменения в проекте. Этот инструмент можно использовать как для индивидуальной, так и для командной работы.
Git позволяет сохранять изменения локально и при необходимости возвращаться к предыдущим версиям проекта. Также можно создать удалённую копию на хостинг-платформе, которая работает с Git, и поделиться результатом с другими.
В этом модуле вы погрузитесь в самостоятельную работу над Git-проектом. А именно:

- cоздадите Git-репозиторий, добавите в него файлы и сделаете свой первый коммит;
- познакомитесь с GitHub — самой популярной платформой для хранения IT-проектов и командной работы над ними;
- научитесь синхронизировать локальный репозиторий, который хранится у вас на компьютере, с удалённым — тем, который вы заведёте на GitHub;
- изучите понятия хеш, лог, HEAD и другие — они помогут вам ориентироваться в коммитах;
- узнаете, как работать с изменениями и правильно оформлять коммиты.

К концу модуля вы сможете создавать Git-проекты и «откатываться» к предыдущим версиям, если что-то пошло не так. А ещё потренируетесь сохранять изменения в удалённой копии — её можно отправить друзьям или коллегам, чтобы похвастаться или спросить совета.

![Modul](https://pictures.s3.yandex.net/resources/D09CD0BED0BDD182D0B0D0B6D0BDD0B0D18F20D0BED0B1D0BBD0B0D181D182D18C2018402x_1690279968.png)

## Инициализируем репозиторий

### Сделать папку репозиторием — git init

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием (от англ. repository — «хранилище»). Для этого следует переместиться в неё и ввести команду git init (от англ. **_initialize_** — «инициализировать»).

Например, создайте папку first-project и сделайте её Git-репозиторием: перейдите в неё с помощью команды cd и выполните git init.

`$ cd ~/dev/first-project # перешли в нужную папку`

`$ git init # создали репозиторий`

Вы можете создать папку в любом месте на компьютере. Но в этом случае не забывайте менять в наших примерах путь ~/dev/first-project на тот, который ведёт к вашей папке. Помните, что не рекомендуется создавать репозиторий Git внутри другого Git-репозитория. Это может вызывать проблемы с отслеживанием изменений.

В некоторых случаях при инициализации репозитория Git может показать объёмное сообщение, которое начинается со слов Using 'master' as the name…. Не пугайтесь: это не ошибка. Пока это сообщение не имеет большого значения.

Почему появляется такое сообщение?

В зависимости от настроек Git может назвать начальную ветку или main, или master. Сообщение появится в том случае, если ветка по умолчанию будет называться master.

После волны протестов Black Lives Matter многие проекты стали отказываться от терминологии, которая может оскорбить темнокожих людей. Слово master можно перевести как «хозяин», поэтому сейчас рекомендуется называть основную ветку main (англ. «главная»).

Подробнее о том, что такое ветки и как с ними работать, мы расскажем в дальнейшем.

Также git init выведет сообщение вида Initialized empty Git repository in <_ваша папка с проектом_>/.git/ (англ. «инициализирован пустой Git-репозиторий в <_ваша папка_>/.git/»). В подпапке .git Git будет хранить всю служебную информацию.

![git init](https://pictures.s3.yandex.net/resources/S1_02_02-1_1684836781.png)

Команда git init — одна из редко применяемых, ведь репозиторий создаётся один раз, а пользоваться им можно сколько угодно долго.

### Разгитить» папку, если что-то пошло не так, — rm -rf .git

Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку .git.

`$ cd <папка с репозиторием> # перешли в папку`

`$ rm -rf .git # удалили подпапку .git`

Разберём подробнее, что такое -rf:

- ключ -r (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;
- ключ -f (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».

![удалили подпапку .git](https://pictures.s3.yandex.net/resources/Artboard20120copy208_1402x_1684836806.png)

Будьте осторожны: в подпапке .git хранится история изменений. Если удалить .git, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.

### Проверить состояние репозитория — git status

После инициализации репозитория first-project запустите команду git status (от англ. status — «статус», «состояние») — она показывает текущее состояние репозитория.

![git status](https://pictures.s3.yandex.net/resources/S1_02_02-7_1684923675.png)

Команда git status выведет:

- название текущей ветки: On branch master или On branch main;
- сообщение о том, что в репозитории ещё нет коммитов: No commits yet;
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — nothing to commit (create/copy files and use "git add" to track).

Подробнее о том, что такое коммиты, мы расскажем в следующих уроках.

В отличие от git init, команду git status используют часто. В любой непонятной ситуации стоит посмотреть состояние (статус) репозитория, а потом решить, что делать дальше.

Отлично! Подведём итоги:

- Инициализировать репозиторий можно с помощью команды git init.
- Проверить статус, или состояние, репозитория поможет команда git status.
- Если вы ошиблись и случайно инициализировали не ту папку, можно «разгитить» её — удалить скрытую подпапку .git.

## Добавляем файлы в репозиторий

Вы инициализировали Git-репозиторий, но в нём пока ничего нет. В этом уроке разберём, как добавить туда файлы.

### Подготовить файлы к сохранению — git add

Добавим в репозиторий два файла. Например, файл todo.txt, в котором будет список дел, и readme.txt для информации о проекте.

📌 Почему именно текстовые файлы?

Чаще всего в Git хранят исходный код программ. Но с точки зрения системы контроля версий любой код — это всего лишь текстовый файл. Какой-то специальной логики для хранения программ в ней нет.

Так что Git вполне может быть повседневным инструментом как разработчиков, которые пишут на разных языках программирования, так и администраторов и DevOps, которые, например, работают над файлами конфигураций, или технических писателей, которые создают документацию, и так далее.

Чтобы сделать наши примеры универсальными, мы будем использовать именно текстовые файлы.

Создайте файлы todo.txt и readme.txt в папке first-project и запустите git status, чтобы посмотреть, что изменилось.

`$ touch todo.txt`
`$ touch readme.txt`
`# создали файлы todo.txt и readme.txt`

`$ git status # проверили статус`

Git сообщит, что в папке first-project есть untracked files (от англ. track — «следить», untracked — «неотслеженный», «неотслеживаемый») — ещё не отслеживаемые файлы readme.txt и todo.txt.

![gs](https://pictures.s3.yandex.net/resources/S1_02_02-2_1684837801.png)

Состояние untracked значит, что Git ещё не хранит информацию о версиях файла и не может отследить, как он изменялся.

Сейчас в first-project два файла. Мы хотим отслеживать состояние обоих, поэтому можем использовать команду git add --all (от англ. add — «добавить» + от англ. all — «всё»).

Ключ, или флаг, --all позволяет подготовить к сохранению все файлы в репозитории.

`$ git add --all # подготовили к сохранению все файлы в репозитории`
`$ git status # проверили статус`

Добавлять файлы можно и по одному, без ключа --all.

`$ git add todo.txt`
`$ git add readme.txt`
`$ git status`

Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке в Bash позволяет точка (.)

`$ git add . # добавить всю текущую папку`
`$ git status`
Вы можете использовать любой из этих вариантов — результат будет одинаковый.
![add .](https://pictures.s3.yandex.net/resources/S1_02_02-4_1684837912.png)

Получилось! Файлы, которые отмечены зелёным, теперь отслеживаются и готовы к сохранению. Но сохранения пока не произошло, потому что команда git add только запоминает текущее содержимое (контент) файла.

💡 Чем отличается запоминание от сохранения?

Команда git add не сохраняет содержимое файлов в репозитории. Само сохранение, или фиксацию состояния файлов, называют коммитом (от англ. commit — «совершать», «фиксировать»). «Сделать коммит» значит сохранить текущую версию файла.

Если провести аналогию, команду git add можно сравнить с добавлением товаров в корзину в интернет-магазине, а коммит — с оформлением и оплатой заказа.

Если сейчас отредактировать любой из «зелёных» файлов в папке first-project, он перейдёт в состояние modified (англ. «изменённый») и будет и в «зелёном», и в «красном» списках.

Например, откройте файл todo.txt в любом редакторе (подойдёт даже блокнот) и напишите в нём: 1. Пройти пару уроков по Git..

![redaktion](https://pictures.s3.yandex.net/resources/S1_02_02-2-2_1684837980.png)

Сохраните изменения, а затем снова вызовите команду git status в консоли.

![RezRedaktion](https://pictures.s3.yandex.net/resources/S1_02_02-3_1684838017.png)

Файл todo.txt теперь есть и в «зелёном», и в «красном» списках:

- зелёным отмечена пустая версия файла — в таком виде он был во время последнего запуска команды git add;
- красным отмечена версия с текстом 1. Пройти пару уроков по Git..

Чтобы запомнить новое состояние файла, нужно снова ввести команду git add и передать в качестве параметра имя изменённого файла или ключ --all.

`$ git add todo.txt`
`# или`
`$ git add --all`

![Rez add](https://pictures.s3.yandex.net/resources/S1_02_02-1-2_1684838122.png)

Подробнее о статусах untracked, modified и других мы расскажем в одном из следующих уроков.

В папке проекта два файла: file.txt и table.csv. Как подготовить их к сохранению?

- [x] `$ git add file.txt`
      $ git add table.csv

Сначала добавили один, потом второй.

### Популярные базы данных

- [ ] Oracle
- [x] MySQL
- [x] Microsoft SQL Server
- [x] PostgreSQL
- [ ] Redis
- [ ] Elasticsearch
- [x] SQLite
- [x] MariaDB
- [ ] Solr
- [ ] Neo4j
- [ ] HBase
- [x] Couchbase
- [ ] `$ git add file.csv`
      `$ git add table.txt`
      Мы хотели вас запутать: посмотрите внимательнее на названия файлов...

Ура! Очередной урок позади. Подытожим:

- Команда git add позволяет подготовить файл к сохранению.
- Команда git add --all подготовит к сохранению сразу все файлы.
- С помощью git add . можно добавить в репозиторий текущую папку со всеми файлами.

## Делаем первый коммит

Коммит — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться». Это как если бы вы могли выполнить операцию Ctrl+Z для целой папки (репозитория).

## Выполнить коммит — git commit

Сделать коммит можно командой git commit c ключом -m (от англ. message — «сообщение»), который присваивает коммиту сообщение.

Обычно в таком сообщении поясняется, в чём именно состояли изменения. Это как заметки на полях: благодаря им проще читать и понимать текст. Сообщение коммита выполняет те же функции — улучшает понимание и упрощает навигацию. Оно пишется после ключа -m в кавычках.

Например, перейдите в папку first-project и выполните коммит со следующим комментарием.

`$ git commit -m 'Мой первый коммит!'`

После нажатия Enter текущая версия файлов будет сохранена в репозитории с сообщением Мой первый коммит!. Коммит (по названию команды git commit) — это по сути список файлов с их контентом.

![1-й коммит](https://pictures.s3.yandex.net/resources/S1_02_02-5_1684838712.png)

Команда git commit выведет информацию о коммите:

- [master (root-commit) baa3b6e] значит:
  коммит был в ветке master;
- root-commit — это самый первый, или «корневой» (англ. root), коммит в ветке, у следующих коммитов такой надписи не будет;
- baa3b6e — сокращённый идентификатор коммита (подробнее об этом мы ещё расскажем).
- 2 files changed, 1 insertion(+) значит:
  изменились два файла (readme.txt и todo.txt);
- одна строка была добавлена (1. Пройти пару уроков по Git.).

Строки вида create mode 100644 readme.txt — это более подробная информация о новых (добавленных в Git) файлах:

- create (англ. «создать») говорит, что файл был создан. Если бы файл был удалён, на этом месте было бы слово delete (англ. «удалить»).
- mode 100644 сообщает, что это обычный файл. Также возможны варианты 100755 для исполняемых файлов (например, что-нибудь.exe) и 120000 для файлов-ссылок в Linux. Файлы-ссылки не содержат данных сами по себе, а только ссылаются на другие файлы — как «ярлыки» в Windows.

💡 Обратите внимание: после того как вы сделали первый коммит, команда git status перестала выводить сообщение No commits yet (англ. «ещё нет коммитов»).

## Ещё раз о разнице между git add и git commit

Сначала команда git add сообщает Git, какие именно файлы нужно сохранить и какую их версию. Затем с помощью команды git commit происходит само сохранение.

В прошлом уроке мы сравнили add c добавлением товаров в корзину, а commit — с заказом. Теперь проведём ещё одну аналогию — с фотографией.

Сначала вы просите друзей встать в ряд — это команда git add. И только после того, как все заняли свои места, поправили волосы и улыбнулись, вы нажимаете кнопку и делаете снимок — это команда git commit. Сам получившийся снимок и будет коммитом. В нашем случае на этой фотографии с обратной стороны ещё есть подпись «Мой первый коммит!».

![Image add + commit](https://pictures.s3.yandex.net/resources/Artboard20120copy205_1402x_1684838813.png)

Кстати, Мой первый коммит! — всё же не лучший вариант сообщения. Коммит нужно описывать так, чтобы было понятно, какие именно изменения были сделаны. Например: Добавлено важное дело в TODO, Добавлена сортировка имён, Исправлена ошибка в цикле или Добавлены заготовки рекламных текстов.

**_Задание для самостоятельной работы_**

Попробуйте самостоятельно сделать несколько коммитов в репозитории first-project.

1. Откройте файл readme.txt в любом редакторе (например, в блокноте).
2. Добавьте в файл описание проекта, например: Тренировочный проект для работы с Git..
3. Сделайте коммит с подходящим сообщением.
4. В файле todo.txt замените 1. Пройти пару уроков по Git. на `1. Пройти пару тем по Git.`.
5. Сделайте ещё один коммит.

Поздравляем с первыми коммитами! Напомним, о чём мы рассказали:

- Коммит можно сделать с помощью команды git commit.
- Ключ -m позволяет присвоить коммиту сообщение. Помните, что такие сообщения должны быть информативными: чётко описывать изменения.
- В коммит попадает то, что было предварительно добавлено «в корзину», или «в кадр», перед коммитом.

## Просматриваем историю коммитов

В этом уроке разберём, как вывести историю коммитов, — это понадобится для отслеживания того, что происходит в репозитории.

### Просмотреть историю коммитов — git log

В самостоятельном задании прошлого урока вы сделали три коммита в ваш репозиторий. Чтобы увидеть их все, введите команду git log (от англ. log — «журнал [записей]»).

![Git log](https://pictures.s3.yandex.net/resources/S1_02_02-8_1684923937.png)

Обратите внимание, что по умолчанию git log выводит коммиты в обратном хронологическом порядке — последние коммиты оказываются первыми сверху. В этом можно убедиться, если посмотреть на дату и время их создания.

Если после выполнения команды вы видите, что в репозитории есть только один коммит или их нет вообще, вернитесь к прошлому уроку и убедитесь, что git add и git commit были вызваны в нужном порядке.

## Знакомство с GitHub

До этого момента вы использовали Git локально: сейчас проект first-project хранится только на вашем компьютере. Но одно из ключевых преимуществ Git — удобство командной работы над файлами. Чтобы поделиться репозиторием — например, с коллегами, — нужно завести его удалённую версию.

Процесс командной работы может выглядеть так: вы работаете над файлами проекта, например пишете код, на своём компьютере и сохраняете в локальном репозитории. Как только накапливается достаточно правок, чтобы поделиться ими с остальными, вы передаёте их на удалённый репозиторий. Там ваши коллеги смогут посмотреть то, что получилось, и даже скачать себе на компьютер.

![Что такое GitHub](https://pictures.s3.yandex.net/resources/S1_02_03_1684925317.png)

### Что такое GitHub

[GitHub](https://practicum.yandex.ru/trainer/git-basics/lesson/93867907-b2f9-452a-a73b-d9b11ae1c65c/) — платформа для хранения IT-проектов и совместной работы над ними с использованием Git. По сути, это сайт, куда можно загрузить файлы своего проекта для обмена с другими людьми.

С английского языка слово hub переводится как «узловая станция». И действительно, GitHub стал самым популярным сайтом для хранения Git-репозиториев. Многие крупные компании, такие как Google, Apple, Valve, используют GitHub для своих проектов.

GitHub подходит, чтобы отточить навыки работы с Git. Здесь можно завести аккаунт и вместе со своей командой работать над любыми задачами. Можно создавать проекты разных типов:

- приватный — только для вас;
- командный — только для членов команды;
- публичный — будет виден всем.

Также можно присоединиться к чужому open source проекту и работать над ним вместе с другими людьми со всего мира.

А ещё GitHub — это социальная сеть для разработчиков. С момента своего возникновения в 2008 году она, [согласно статистике](https://practicum.yandex.ru/trainer/git-basics/lesson/93867907-b2f9-452a-a73b-d9b11ae1c65c/), объединила десятки миллионов человек, дала им возможность для реализации идей и сотрудничества.

### Git и платформы для удалённой работы

Git и GitHub — это два разных проекта, которые развиваются независимо друг от друга.

**Git:**

- консольный инструмент для работы с локальными и удалёнными репозиториями;
- проект с открытым исходным кодом.

**GitHub:**

- платформа для размещения удалённых репозиториев;
- принадлежит компании Microsoft.

Кроме GitHub, есть и другие платформы для командной работы. Например, GitLab и Bitbucket, которые тоже позволяют работать с Git. У каждой из этих платформ свои особенности и дополнительная функциональность:

- GitLab можно развернуть в виде сервера в приватной сети;
- Bitbucket — продукт компании Atlassian, поэтому он легко интегрируется с другими инструментами этой компании, такими как Jira.
  В этом курсе вы будете взаимодействовать с GitHub. Но в целом эти платформы похожи, и если вы изучите одну из них, то переход на другую не будет проблемой.

💡 Можно ли делать сложные проекты без GitHub?
Такие платформы, как GitHub, Bitbucket и другие, значительно упрощают процесс командной работы. Но при этом Git может использоваться и без них для создания даже больших проектов.  
Например, ядро Linux — самой популярной операционной системы для серверов, телефонов и суперкомпьютеров — разрабатывают с помощью патчей (от англ. patch — «заплата», «лоскут»). Это файлы, которые содержат отличия исходной версии от последующих.  
Такие патчи рассматривает и объединяет в основную версию ядра лично Линус Торвальдс — создатель Linux и Git. Это происходит без использования средств платформ вроде GitHub.

Поздравляем: у вас появился новый друг в мире Git! Коротко напомним, о чём шла речь в этом уроке:

- GitHub — платформа, которая работает с Git и упрощает командное взаимодействие.
- Кроме GitHub, существуют и другие подобные платформы, например GitLab, Bitbucket и так далее.
- Git — это консольный инструмент для работы с локальными и удалёнными репозиториями. Он не связан напрямую ни с одной из платформ и развивается отдельно от них.

## Регистрация на GitHub

Вы познакомились с платформой GitHub — пришло время зарегистрироваться на ней. Поехали!

### Инструкция по регистрации

1. В правом верхнем углу [главной страницы GitHub](https://practicum.yandex.ru/trainer/git-basics/lesson/f7e00d04-1da2-46b4-b13d-b0bf751caf88/) нажмите на Sign up (англ. «зарегистрироваться»).

![Sign up](https://pictures.s3.yandex.net/resources/S1_02_03-2_1684933141.png)

2.На экране будут последовательно появляться поля для ввода.
2.1. Введите адрес электронной почты (англ. Enter your email).
2.2. Придумайте пароль (англ. Create a password).
2.3. Введите имя пользователя (англ. Enter a username).

1. Платформа спросит, хотите ли вы получать на почту рассылку с обновлениями и новостями (англ. Would you like to receive product updates and announcements via email?). Введите y, если хотите получать рассылку, или n, если не хотите.

2. Нажмите кнопку Continue (англ. «продолжить»).
3. GitHub предложит вам пройти капчу. Сделайте это.
4. После прохождения капчи нажмите Create account (англ. «создать аккаунт»).
5. Введите короткий код, который будет отправлен на указанный вами почтовый адрес.

![Enter code](https://pictures.s3.yandex.net/resources/S1_02_03-1_1684933748.png)

Поздравляем! Вы успешно зарегистрировались на крупнейшем веб-хостинге проектов GitHub. Теперь у вас есть возможность работать бок о бок с миллионами профессионалов по всему миру, обмениваться идеями и развиваться.

![Веб-хостинг проектов GitHub](https://pictures.s3.yandex.net/resources/Artboard20120copy204_1402x_1684933764.png)

## Создаём удалённый репозиторий

### Инструкция по созданию репозитория на GitHub

1.Зайдите в свой профиль по ссылке <https://github.com/username>, где username — имя, которое вы указали при регистрации.

Эта страница — презентация вас и ваших проектов. Её видят другие пользователи. Надпись You don't have any public repositories yet (англ. «у вас пока нет публичных репозиториев») сообщает, что пока у вас нет проектов.

![Эта страница — презентация вас и ваших проектов](https://pictures.s3.yandex.net/resources/S1_02_03-1-2_1684935796.png) 2. Создайте репозиторий. Для этого перейдите на вкладку Repositories (англ. «репозитории»), а затем нажмите на зелёную кнопку New (англ. «новый») справа.

![Создайте репозиторий](https://pictures.s3.yandex.net/resources/S1_02_03-3_1684935815.png) 3. Открылось окно создания нового репозитория. Назовите его first-project. Название удалённого репозитория необязательно должно совпадать с именем папки проекта у вас на компьютере. Но чтобы не путаться, будем называть их одинаково.

Другие поля вам пока не понадобятся. Смело нажимайте на зелёную кнопку Create repository (англ. «создать репозиторий») внизу.

![Create repository ](https://pictures.s3.yandex.net/resources/S1_02_03-3-2_1684935833.png)

Готово! Удалённый репозиторий создан. Страница с ним открывается автоматически.

![Удалённый репозиторий создан](https://pictures.s3.yandex.net/resources/S1_02_03-2-3_1684935849.png)

Осталось связать удалённый репозиторий с локальным, который уже есть на вашем компьютере. GitHub предоставляет для этого инструкцию (пункт …or push an existing repository from the command line).

Но прежде, чтобы упростить работу с GitHub и сделать её более безопасной, вы научитесь генерировать SSH-ключи (от англ. Secure Shell — «безопасная оболочка»). Об этом в следующем уроке.

## Что такое SSH. Генерируем SSH-ключ

Представьте, что у вас есть ключ от двери, за которой хранится важный документ. Чтобы получить доступ к этому документу, вам нужно вставить ключ в замочную скважину и повернуть его. Поскольку ключ есть только у вас, ваш документ надёжно защищён от посторонних глаз.

Чтобы получить доступ к репозиторию на GitHub, вам тоже нужно предоставить ключ, который подтверждает вашу личность и права на чтение или изменение данных. Без этого ключа доступ будет ограничен. Об этом и пойдёт речь в уроке.

## Что такое SSH

Когда компьютеры обмениваются данными в сети, они следуют сетевым протоколам (англ. network protocols) — правилам обмена данными между компьютерами.
Один из наиболее распространённых сетевых протоколов — SSH (от англ. Secure Shell Protocol). Он обеспечивает безопасный обмен данными в сети. С помощью этого протокола можно получать данные с удалённого компьютера или отправлять их на него. Трафик шифруется, поэтому протокол безопасен.
SSH использует пару ключей для обеспечения безопасности — публичный и приватный:

- Приватный ключ (англ. private key) хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.
- Публичный ключ (англ. public key) доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.
  Только вы можете расшифровать данные с помощью приватного ключа, но любой владелец публичного ключа может их для вас зашифровать. Эти два ключа связаны и образуют SSH-пару. В будущем вы наверняка будете использовать их для взаимодействия с GitHub и другими удалёнными серверами.

## Проверка наличия SSH-ключа

Прежде чем генерировать SSH-ключи, убедитесь, что у вас их ещё нет. По умолчанию директория с SSH-ключами находится в домашней директории пользователя. Перейдите в неё.
`$ cd ~ # перешли в домашнюю директорию`
Обычно SSH-ключи находятся в директории .ssh/. Проверить наличие этой директории и файлов в ней можно с помощью следующей команды.
`$ ls -la .ssh/ # вывели список созданных ключей`
Если папка пустая или её нет, всё в порядке.
Если есть файлы с похожими названиями, SSH-ключи уже создавались:

- id_dsa.pub;
- id_ecdsa.pub;
- id_ed25519.pub;
- id_rsa.pub.
  Если вы не создавали эти файлы, удалите их все.

### Инструкция по генерации SSH-ключа

1. Для генерации SSH-пары можно использовать программу ssh-keygen. Откройте терминал и введите следующую команду.
   `$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"`
   Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.
   Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519. Ничего страшного: используйте другой алгоритм.
   `$ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"`
   После ввода отобразится такое сообщение.
   `> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи`
2. Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите Enter.
   **Windows**
   `> Enter a file in which to save the key (C:\Users\<имя_пользователя>\.ssh\):[Press enter]`
   Теперь в указанной директории появится пара ключей.
3. Программа запросит кодовую фразу (англ. passphrase) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите Enter, а затем ещё раз Enter для подтверждения.
   `> Enter passphrase (empty for no passphrase): [Type a passphrase]`
   `> Enter same passphrase again: [Type passphrase again]`
   💡 Быть или не быть кодовой фразе — вот в чём вопрос
   Как бы странно ни звучало, кодовая фраза — это «пароль от ключа». Представьте, что SSH-ключ лежит в шкатулке. А на самой шкатулке — кодовый замок, который открывается кодовой фразой.
   Многие пользователи Git не используют кодовую фразу для защиты своего SSH-ключа. Если такой фразы нет, то её не нужно вводить всякий раз при взаимодействии с удалённым репозиторием.
   С другой стороны, применение кодовой фразы усиливает безопасность ключей. Если вы используете эту фразу, ключ будет надёжно защищён в случае несанкционированного доступа к вашему компьютеру.
4. Готово! Теперь осталось проверить, что ключи действительно сгенерировались. Для этого вызовите эту команду.
   `ls -a ~/.ssh`
   На экране должны появиться два файла — один с расширением .pub, другой — без. Файл в .pub — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому!
   Вся последовательность действий в консоли показана на скриншоте ниже.
   ![SSH](https://pictures.s3.yandex.net/resources/M2_T4_01_1684937563.png)
   Замечательно! Подведём итоги:

- SSH — протокол, который обеспечивает безопасный обмен данными в сети и использует для этого ключи.
- SSH-ключ — ваш виртуальный идентификатор в GitHub. Как ключ от квартиры, он позволяет получить доступ к GitHub-репозиторию. Также SSH используется для доступа к другим удалённым серверам.
- SSH-ключ состоит из двух частей — публичной и приватной. Публичный ключ зашифрует данные, а приватный — расшифрует. Приватным ключом ни в коем случае нельзя делиться, иначе любой сможет расшифровать все ваши секреты!

## Изучаем Git и GitHub

## Привязываем SSH-ключ к GitHub

В прошлом уроке вы сгенерировали SSH-ключ, но он пока не привязан к аккаунту на GitHub. Исправим это.

## Инструкция по связыванию SSH-ключа и GitHub-аккаунта

1.После выполнения команды ssh-keygen из предыдущего урока в директории ~/.ssh будет создано два файла — id_ed25519 и id_ed25519.pub (или id_rsa и id_rsa.pub — в зависимости от того, какой алгоритм вы использовали):

- id_ed25519/id_rsa — приватный ключ (файл без .pub в конце). Ни в коем случае не копируйте его и не делитесь им.
- id_ed25519.pub/id_rsa.pub — публичный ключ (на это указывает расширение .pub).
  **Windows**

### скопировать содержимое ключа в буфер обмена

`$ clip < ~/.ssh/id_rsa.pub`
`# для ed25519:`
`$ clip < ~/.ssh/id_ed25519.pub`
В качестве альтернативы вы можете распечатать файл на экран с помощью cat ~/.ssh/id*rsa.pub и скопировать его вручную.
Если clip не сработает, выведите содержимое файла с помощью cat ~/.ssh/id_rsa.pub или cat ~/.ssh/id_ed25519.pub и скопируйте вывод в буфер обмена из консоли.
2.Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта.
![Settings](https://pictures.s3.yandex.net/resources/M2_T4_03_01_1685016747.png)
3.В меню слева нажмите на пункт SSH and GPG keys.
![Settings](https://pictures.s3.yandex.net/resources/M2_T4_03_02_1685016772.png)
4.В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»).
![Settings](https://pictures.s3.yandex.net/resources/M2_T4_03_03_1685016795.png)
5.В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»).
6.В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»).
7.В поле Key скопируйте ваш ключ из буфера обмена.
![Settings](https://pictures.s3.yandex.net/resources/M2_T4_03_04_1685016816.png)
8.Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»).
![Settings](https://pictures.s3.yandex.net/resources/M2_T4_03_05_1685016840.png)
9.Проверьте правильность ключа с помощью следующей команды.
`$ ssh -T git@github.com`
Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится похожее предупреждение.
`The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])?`
Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт.
Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub [по этой ссылке](https://practicum.yandex.ru/trainer/git-basics/lesson/4d662a58-3602-4c5c-9fad-be8cff334f37/). Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите yes, чтобы продолжить. Вы увидите приветствие на экране.
`Hi %ВАШ*АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.`
Если у вас возникли сложности при генерации или привязке SSH-ключей, посмотрите видеоинструкцию, в которой мы показываем всё по порядку.

[![Посмотреть видеоинструкцию по генерации и привязке SSH-ключей]({image-url})]({<video controls src="https://code.s3.yandex.net/git_Basic/SSH_Screencast.mp4" title="video-ur">`</video>`l} "Link Title")

Ура: теперь ваш ключ привязан к GitHub! Если вы установили кодовую фразу для SSH-ключа, её нужно будет вводить для работы с репозиторием.

**_Связываем локальный и удалённый репозитории_**

Сейчас у вас есть локальный репозиторий first-project, который хранится на вашем компьютере, и удалённый репозиторий на GitHub. Вы сгенерировали SSH-ключ для безопасной работы и теперь готовы связать удалённый репозиторий с локальным.

![Привязать удалённый репозиторий к локальному — git remote add](https://pictures.s3.yandex.net/resources/Artboard20120copy206_1402x_1685021899.png)

**_Привязать удалённый репозиторий к локальному — git remote add_**

Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL. Кнопка справа позволит сделать это мгновенно.

![Cкопируйте URL](https://pictures.s3.yandex.net/resources/M2_T4_02_1685021914.png)

Откройте консоль, перейдите в каталог локального репозитория и введите команду git remote add (от англ. remote — «удалённый» и add — «добавить»).

`$ cd ~/dev/first-project`

`$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git`

Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово origin. А URL вы скопировали со страницы удалённого репозитория.

💡 Как выполнить вставку в командную строку?

В командную строку нельзя вставить текст из буфера обмена с помощью привычного сочетания Ctrl+V. На Windows (в Git Bash) и Linux для этого используется сочетание Ctrl+Shift+V, а на macOS — Cmd+V.

Также можно нажать правую кнопку мыши и выбрать пункт Paste (англ. «вставить») в выпадающем меню.

**_Убедиться, что репозитории связаны, — git remote -v_**

Отлично: вы связали локальный репозиторий с удалённым.
Осталось убедиться, что всё работает, с помощью следующей команды.

`$ git remote -v`

`origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)`

`origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)`

В выводе вы должны увидеть две строчки, аналогичные тем, что показаны выше.

Флаг -v — короткая форма флага --verbose (англ. «подробный»). Он позволяет показать больше информации в выводе.

Локальный и удалённый репозитории связаны!

## Синхронизируем локальный и удалённый репозитории

Вы зарегистрировались на GitHub, сгенерировали SSH-ключ и привязали локальный репозиторий к удалённому. Самое сложное позади! Теперь разберём, как выкладывать свои правки на удалённый репозиторий. Но сначала немного о ветках.

### Основная ветка

Мы упоминали, что каждый коммит сохраняет актуальное состояние файлов. Сами же коммиты хранятся в ветках (англ. branch).

Если коммит — это снимок состояния файлов, то ветка — временна́я шкала, на которой расположены эти снимки. Ветка всегда начинается от одного из коммитов.

В репозитории может существовать сразу несколько веток — параллельных историй изменений. Также они могут соединяться друг с другом.

![Основная ветка](https://pictures.s3.yandex.net/resources/M2_T4_01-2_1685963656.png)

Самая первая ветка в репозитории появляется автоматически и называется main (англ. «основная») или master. Её имя нужно указывать при отправке коммитов на удалённый репозиторий или при получении их из него.

💡 main или master?

Раньше основная ветка в репозиториях, созданных на GitHub, называлась master, но с 1 октября 2020 года (после волны протестов движения Black Lives Matter) её переименовали в main.

Во всех репозиториях, созданных раньше этой даты, название основной ветки не поменялось. Поэтому в проектах, которые начали именно с master, и в руководствах по работе с Git вы по-прежнему можете встретить имя master.

## Отправить изменения на удалённый репозиторий — git push

Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью git add, закоммитили их с комментарием командой git commit -m. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда git push (от англ. push — «толкать»).

В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.

`$ git push -u origin main`  
_Если команда приведёт к ошибке, попробуйте заменить main на master_

Появится такой экран

![такой экран](https://pictures.s3.yandex.net/resources/M2_T4_02-2_1685963722.png)

При взаимодействии с удалёнными репозиториями Git выводит в консоль отладочную информацию: количество объектов (файлов), которые отправляются на сервер, информацию о прогрессе сжатия и записи и так далее.

Если вы указывали кодовую фразу при настройке SSH-ключей, её нужно будет ввести.

Зайдите в репозиторий first-project на GitHub. Вы увидите, что в репозитории появились файлы с изменениями.

![файлы с изменениями](https://pictures.s3.yandex.net/resources/M2_T4_03_01-2_1685963748.png)

В дальнейшем при работе с удалённым репозиторием флаг -u можно опустить и писать просто git push

## Работа с графическим интерфейсом GitHub

GitHub предоставляет удобный интерфейс для работы с репозиторием. Например, нажмите на кнопку commit в правой части страницы, чтобы просмотреть все коммиты в репозитории.

![Kнопкa commit в правой части страницы](https://pictures.s3.yandex.net/resources/M2_T4_03_02-2_1685963765.png)

Откроется окно с коммитами и их авторами.

![Oкно с коммитами](https://pictures.s3.yandex.net/resources/M2_T4_03_03-2_1685963782.png)

Сообщение коммита в репозитории тоже является ссылкой.

![Сообщение коммита](https://pictures.s3.yandex.net/resources/M2_T4_03_04-2_1685963797.png)

Перейдите по ссылке, кликните на текст последнего коммита над репозиторием — так вы сможете увидеть все изменения, которые были внесены в репозиторий в этом коммите.

![текст последнего коммита](https://pictures.s3.yandex.net/resources/M2_T4_03_05-2_1685963809.png)

**_Задание для самостоятельной работы_**

1. Откройте проект first-project и создайте в нём файл task.txt с помощью touch.
2. Откройте файл task.txt в текстовом редакторе и внесите любые изменения. Затем сохраните и закройте файл.
3. Сделайте коммит и синхронизируйте изменения с удалённым репозиторием.

`$ git push`

Воспользуйтесь интерфейсом GitHub, чтобы посмотреть ваш последний коммит. Для этого нажмите на имя коммита.

Теперь ваши изменения могут увидеть те, кому вы отправите ссылку на проект!

Копилка ваших знаний о Git постепенно пополняется! Вот о чём мы рассказали:

- Коммиты хранятся в ветках. Начальная ветка создаётся автоматически и называется main или master.
- За отправку изменений на удалённый репозиторий отвечает команда git push.
- Интерфейс GitHub позволяет удобно просмотреть все коммиты в репозитории, а также изменения в этих коммитах.

## Файл README.md

Чтобы другие пользователи, а также потенциальные клиенты или работодатели могли понять, что представляет собой проект, его нужно описать. Такое описание принято указывать в файле README.md (от англ. read — «прочитай» и me — «меня»). В этом уроке вы научитесь оформлять такие файлы.

### Подробнее о том, зачем нужен README.md

Как правило, в README.md проекта можно найти следующую информацию:

1. Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.

2. Технологии, которые применяются в проекте. В чём его отличие от аналогичных.

3. Документация проекта — подробная инструкция о том, что представляет собой проект.

4. Планы проекта, если они есть.

Вот пример файла README.md для Git [на GitHub](https://practicum.yandex.ru/trainer/git-basics/lesson/c6b9607c-e8bc-4446-89f9-c74522c3492f/)

### Как создать и оформить README.md

README.md — текстовый файл, который можно создать командой touch, а затем редактировать так же, как и любой другой текстовый документ. Например, в блокноте.

Преимущество README.md в том, что средства командной работы (такие, как GitHub) могут отображать его содержимое в браузере в виде удобной разметки. Для этого нужно не просто залить текст, но и настроить шрифт, заголовки и отступы с помощью markdown. Маркда́ун — это специальный язык разметки. Он позволяет красиво отформатировать текстовый документ.

Разберём базовый синтаксис этого языка. Все правила запоминать не нужно: при оформлении репозитория вы всегда можете вернуться к этому уроку.

### Заголовки, абзацы и перенос

- Заголовки разных уровней создают решётками.

`# H1 — заголовок первого уровня, самый большой`

`## H2 — заголовок второго уровня, поменьше`

`### H3`

`#### H4`

`##### H5`

`###### H6 — заголовок шестого уровня, самый маленький`

`# H1 — заголовок первого уровня, самый большой

## H2 — заголовок второго уровня, поменьше

### H3

#### H4

##### H5

###### H6 — заголовок шестого уровня, самый маленький

- Можно добавить черту под заголовком или абзацем.

`#### Заголовок 4`

`Текст над чертой`

---

`Текст под чертой`

#### Заголовок 4

Текст над чертой

---

Текст под чертой

- Чтобы сделать разрыв строки, нужно поставить два пробела (в примере ниже они обозначены точками ⋅⋅) или сочетание символов `<br>`.

Текст до переноса⋅⋅  
Текст после переноса `<br>`
Текст после второго переноса

- Чтобы начать новый параграф, в конце предыдущей строки должно стоять два символа переноса. Для этого нужно нажать Enter два раза.

Чтобы начать новый параграф, в конце предыдущей строки должно стоять два символа переноса.`<br><br>`

Для этого нужно нажать Enter два раза.

line

another line

### Выделение текста

Чтобы выделить текст курсивом (_текст_), его заключают в звёздочки (астериски) или нижние подчёркивания.

`Курсив — это *звёздочки* или _подчёркивания_.`

- Чтобы выделить текст полужирным шрифтом (**текст**), его окружают двойными звёздочками или двойными нижними подчёркиваниями.

`Полужирный шрифт — двойные **звёздочки** или двойные __подчёркивания__.
Можно совместить выделение **звёздочки и _подчёркивания_**.`

- Чтобы зачеркнуть текст (~~текст~~), его окружают двойными волнистыми линиями — тильдами.

`~~Зачёркнутый текст.~~`

~~Зачёркнутый текст.~~

### Списки

- Для оформления нумерованного списка достаточно поставить в начало строки цифры с точкой.

1. Первый пункт нумерованного списка.
2. Второй пункт.

- Ненумерованный список создаётся звёздочкой с пробелом в начале строки либо дефисом с пробелом.

- первый пункт ненумерованного списка;
- второй пункт ненумерованного списка

- первый пункт ненумерованного списка;
- второй пункт ненумерованного списка

### Ссылки

Чтобы сделать ссылкой часть текста, его заключают в квадратные скобки, а затем указывают нужный адрес в круглых скобках.

`[Яндекс](https://www.yandex.ru)`

[Яндекс](https://www.yandex.ru)

- Также можно добавить ссылке тайтл (от англ title — «название», «заголовок»). Тайтл — это всплывающая подсказка, которая появляется при наведении мыши на ссылку. Тайтл нужно заключить в кавычки и указать внутри скобок после адреса.

`[Яндекс](https://www.yandex.ru "Я Yandex!")`

[Яндекс](https://www.yandex.ru "Я Yandex!")

### Код

Чтобы оформить текст как код, нужно окружить его тройками косых кавычек — грависов. После первой тройки грависов указывают язык программирования, на котором написан код. В маркдауне есть поддержка синтаксиса почти всех популярных языков и инструментов.

`bash
ls - la`

`html`

`<h1>А я просто текст</h1>`

```bash
ls - la
```

```html
<h1>А я просто текст</h1>
```

Обратите внимание: вторая тройка тройных кавычек стоит на отдельной строке.

### Пример файла README.md

Если собрать всё вместе, файл README.md может выглядеть так.

`# Шпаргалка markdown`

`## Выделение текста`

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

`Пример _курсива_ и **жирного** текста.`

`## Заголовки`

А вот так этот файл будет встречать гостей репозитория.

![Шпаргалка markdown](https://pictures.s3.yandex.net/resources/M2_T4_03_1685964697.png)

**_Задание для самостоятельной работы_**

Потренируйтесь использовать маркдаун. Оформите файл README.md для репозитория first-project. Сейчас в нём есть файл readme.txt, который вы создали в начале модуля. Удалите файл и создайте новый с расширением .md.

`$ cd ~/dev/first-project`

`$ rm readme.txt`

`$ touch README.md`

`# затем файл README.md можно редактировать как обычно`

`# с помощью любого текстового редактора (например, блокнота)`

Вы можете применять любые инструменты разметки, которые мы показали в этом уроке, или добавить что-нибудь от себя. Загляните в руководства по маркдауну — например, в [шпаргалку на GitHub](https://practicum.yandex.ru/trainer/git-basics/lesson/c6b9607c-e8bc-4446-89f9-c74522c3492f/) или [в этот гайд](https://practicum.yandex.ru/trainer/git-basics/lesson/c6b9607c-e8bc-4446-89f9-c74522c3492f/).

Отлично: теперь вы умеете оформлять файл README.md — он поможет другим пользователям узнать больше о проекте, который вы разместили в вашем репозитории!

## Хеш — идентификатор коммита

В процессе работы с Git вам будет часто встречаться понятие «хеш коммита». Эти странные строчки с бессмысленным (на первый взгляд) набором букв и цифр вы могли видеть, когда вызывали команду git log и выводили историю коммитов.

![Вызов команды git log](https://pictures.s3.yandex.net/resources/M2_T5_04-2_1686651606.png)

### Что такое хеш. Хеширование коммитов

[**Хеширование**](https://practicum.yandex.ru/trainer/git-basics/lesson/27b75a18-4c7c-4e4c-a216-39b30dc2fef6/)— это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.

Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.

Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0—9 и латинских букв A—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:

- если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
- если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

Чтобы убедиться в этом, можно поэкспериментировать с SHA-1 [на этом сайте](https://practicum.yandex.ru/trainer/git-basics/lesson/27b75a18-4c7c-4e4c-a216-39b30dc2fef6/) — попробуйте ввести в поле input (англ. «ввод») разные символы, слова или предложения и понаблюдайте, как меняется хеш в поле output (англ. «вывод»).

## Хеш — основной идентификатор коммита

Git хранит таблицу соответствий хеш → информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.

При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.

Все хеши и таблицу хеш → информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта.

Отлично! Теперь вы знаете, что такое хеш коммита и для чего он нужен. Подведём итоги:

- Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш.
- Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.
- Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке .git.

## Исследуем лог

В этом уроке рассмотрим подробнее, из каких элементов состоит описание коммита, а также как вывести сокращённый лог (от англ. log — «журнал [записей]»). Сокращённый лог полезен, если нужно быстро найти нужный коммит среди сотни других.

## Элементы описания коммита

После вызова git log появляется список коммитов.

![После вызова git log](https://pictures.s3.yandex.net/resources/M2_T5_02_1685969923.png)

Разберём элементы, из которых состоит описание:

- строка из цифр и латинских букв после слова commit — это хеш коммита;
- Author — имя автора и его электронная почта;
- Date — дата и время создания коммита;
- в конце находится сообщение коммита.

Исходный код самого Git тоже хранится в Git-репозитории (тут уместно вспомнить про курицу и яйцо). Вот так выглядит описание самого первого коммита в репозитории Git. Изучите его.

commit e83c5163316f89bfbde7d9ab23ca2e25604af290
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date: Thu Apr 7 15:13:13 2005 -0700

Initial revision of "git", the information manager from hell

## Получить сокращённый лог — git log --oneline

Получить сокращённый лог можно с помощью команды git log с флагом --oneline (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.

![git log --oneline](https://pictures.s3.yandex.net/resources/M2_T5_03_1685970110.png)

- Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.
- Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

💡 Обратите внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу Q (от англ. Quit — «выйти») в английской раскладке клавиатуры.

Здорово! Самое важное в этом уроке:

- Можно вызвать не только полный лог, но и сокращённый — это делается командой git log --oneline.
- В сокращённом логе выводятся сокращённые хеши — их можно использовать точно так же, как и полные.

## HEAD — всему голова

При вызове команды git log вы также могли заметить надпись (HEAD -> master) после хеша одного из коммитов. В этом уроке расскажем, что она означает.

![HEAD -> master](https://pictures.s3.yandex.net/resources/M2_T5_01_1685972979.png)

### Файл HEAD

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).

В этом можно убедиться с помощью терминала. Перейдите в папку .git командой cd. Посмотрите содержимое файла HEAD командой cat.

`$ pwd # посмотрели, где мы`

`/Users/user/dev/first-project`

`$ cd .git/`

`$ ls # посмотрели, какие есть файлы`

COMMIT_EDITMSG ORIG_HEAD description index logs/ refs/
HEAD config hooks/ info/ objects/

`$ cat HEAD # команда cat показывает содержимое файла`

`ref: refs/heads/master # в файле вот такая ссылка`

Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

`$ cat refs/heads/master # взяли ссылку из файла HEAD`

`# внутри хеш`

`e007f5035f113f9abca78fe2149c593959da5eb7`

`$ git log`

`# сверяем с хешем последнего коммита`

commit e007f5035f113f9abca78fe2149c593959da5eb7

Author: John Doe <johndoe@example.com>

Date: Tue Mar 28 00:26:53 2023 +0300

Добавить амбиций в список дел

`... # другие коммиты`

Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.

При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.

Супер! Папка .git содержит много непонятных файлов — об одном из них мы рассказали в этом уроке. Подытожим:

- В числе прочих файлов в папке .git есть служебный файл HEAD. Он указывает на самый свежий коммит.

- Вместо хеша последнего коммита можно написать слово HEAD — Git вас поймёт.

## Статусы файлов в Git

До появления Git системы контроля версий выделяли только два статуса у файлов: «уже закоммичен» и «ещё не закоммичен». Например, в Subversion (самой популярной VCS до эпохи Git) не нужно было выполнять команду — аналог git add, а можно было просто сделать коммит (svn commit). Эта команда по умолчанию добавляла в коммит все новые и изменённые файлы.

Такое поведение интуитивно более понятно. Зато Git даёт больше контроля за состоянием файлов. Хотя сначала это может показаться сложным, со временем вы оцените удобство более явного подхода.

В этом уроке разберём подробнее, в каких состояниях (или статусах) могут находиться файлы в репозитории. А ещё проследим типичный жизненный цикл файла в Git.

## Статусы untracked/tracked, staged и modified

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные:

- untracked (англ. «неотслеживаемый»)

Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.

- staged (англ. «подготовленный»)

После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.

В одном из предыдущих уроков мы сравнили коммит с фотографией. Можно развить эту аналогию и сказать, что команда git add добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а git commit делает снимок всей сцены целиком.

💡 Staging area, index и cache
Staging area также называют index (англ. «каталог») или cache (англ. «кеш»), а состояние файла staged иногда называют indexed или cached.
Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах [на сайте Stack Overflow](https://practicum.yandex.ru/trainer/git-basics/lesson/860e0bf4-ebd6-4e13-87fa-f76d92cfd11f/).

- tracked (англ. «отслеживаемый»)

Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.

modified (англ. «изменённый»)

Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

💡 Для файлов в состояниях staged и modified обычно не указывают, что они также tracked, потому что это состояние подразумевается.

## Про staged и modified

Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.

Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.

## Типичный жизненный цикл файла в Git

Может показаться, что файлы в репозитории попадают в разные состояния хаотично. На практике это не так, и у большинства файлов вполне предсказуемый путь.

![Типичный жизненный цикл файла в Git](https://pictures.s3.yandex.net/resources/M2_T5_1686651284.png)

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.
2. Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked).

- Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked).
  Обратите внимание: staged и modified у одного файла, но у разных его версий.
- Ещё раз выполнили git add. Состояние: staged (+ tracked).

## Сделали коммит с помощью git commit. Состояние: tracked

1. Изменили файл. Состояние: modified (+ tracked).

1. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).

1. Сделали коммит. Состояния: tracked.

1. Повторили пункты 4−7 много-много раз.

Выглядит довольно запутанно! Но на практике разобраться с этим будет проще, чем кажется. Вы сможете наглядно проследить типичный жизненный цикл файла в Git в следующем уроке.

Ура! Это был сложный урок, зато теперь вы знаете о состояниях и жизненном цикле файлов в Git чуть больше. Важное:

- Статусом untracked помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность tracked, в который попадают все файлы, отслеживаемые Git.

- Файл переходит в статус staged после выполнения git add.

- Статус modified означает, что файл был изменён.

- Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.

## Как читать git status

Частая ошибка при использовании Git — закоммитить лишнее или, наоборот, забыть добавить важный файл в коммит. Этого легко избежать, если не забывать проверять статусы файлов с помощью команды git status. Как читать её вывод, покажем в этом уроке.

## Какие состояния показывает git status

Большинство файлов в типичном проекте будут находиться в состоянии tracked (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды git status — иначе она бы каждый раз выводила список вообще всех файлов проекта.

В итоге git status показывает только следующие состояния файлов:

- staged (Changes to be committed в выводе git status);

- modified (Changes not staged for commit);

- untracked (Untracked files).

## Подготавливаем репозиторий

Чтобы попрактиковаться, инициализируйте новый репозиторий ~/dev/git-status-lesson. Создайте в нём файл README.md и закоммитьте его.

`$ cd ~/dev`

`$ mkdir git-status-lesson`

`$ cd git-status-lesson`

`$ git init`

`# тут Git выведет что-нибудь, но мы это пропустим`

`$ touch README.md`

`$ git add README.md`

`$ git commit -m 'Добавить README'`

`~~~~# по традиции первым создадим и закоммитим файл README.md`

Дальше вы будете добавлять в репозиторий файлы и смотреть на их статусы.

## Типичные варианты вывода git status

Рассмотрим четыре примера состояний, в которых может находиться ваш репозиторий.

1. Нет ни staged-, ни modified-, ни untracked-файлов.

Если ничего не менять в git-status-lesson после первого коммита, то в нём не должно быть ни изменённых файлов (modified), ни новых (untracked), ни добавленных в список на коммит (staged). Вызовите команду git status. Её вывод будет примерно таким.

`$ git status`

On branch master
nothing to commit, working tree clean

Это означает, что в репозитории нет новых или изменённых файлов. Последняя строка nothing to commit, working tree clean буквально переводится как «нечего коммитить, рабочая директория чиста».

Первая строка On branch master сообщает, что текущая ветка — master.

1. Найдены неотслеживаемые файлы.

Создайте в папке ~/dev/git-status-lesson файл fileA.txt. Теперь в репозитории есть новый файл в состоянии untracked. Снова вызовите команду git status. Результат будет таким.

`$ touch fileA.txt`

`$ git status`

On branch master
Untracked files: # найдены неотслеживаемые файлы
(use "git add `<file>`..." to include in what will be committed)
fileA.txt

nothing added to commit but untracked files present (use "git add" to track)

Файл fileA.txt отображается в секции неотслеживаемых файлов — Untracked files. Это значит, что он не был добавлен в репозиторий через git add.

💡 Обратите внимание: в самом выводе git status есть подсказка, какую команду использовать, чтобы добавить файл в список на коммит: Use git add `<file>` to include in what will be committed (англ. «используйте git add `<file>`, чтобы добавить в список на коммит»).

Добавьте fileA.txt в staging area с помощью git add и снова запросите git status.

`$ git add fileA.txt`

`$ git status`

On branch master
Changes to be committed: # новая секция
(use "git restore --staged `<file>`..." to unstage)
new file: fileA.txt

💡 В этот раз git status подсказывает, что существует команда git restore. Мы познакомим вас с ней в одном из будущих уроков.

Теперь fileA.txt находится в секции Changes to be committed (англ. «изменения, которые попадут в коммит»). Если сейчас выполнить коммит, то в репозитории будет зафиксирована текущая версия этого файла. Закоммитьте его.

`$ git commit -m 'Добавить файл fileA.txt'`

`# тут будет вывод комманды commit, он нас не интересует`

`$ git status`

On branch master
nothing to commit, working tree clean

Вывод команды git status такой же, какой был после первого коммита: «Директория чиста».

## Найдены изменения, которые не войдут в коммит

Теперь откройте файл fileA.txt и добавьте в него несколько слов — например, Это файл A!. Сохраните fileA.txt и вызовите команду git status. Её результат будет такой.

`# внесли в fileA.txt правки`

`# запросили статус`

`$ git status`

On branch master
Changes not staged for commit: # ещё одна секция
(use "git add `<file>`..." to update what will be committed)
(use "git restore `<file>`..." to discard changes in working directory)
modified: fileA.txt

Файл fileA.txt был изменён, но ещё не добавлен в staging area после этого. Так он оказался в секции Changes not staged for commit (англ. «изменения, которые не подготовлены к коммиту»). Эта секция соответствует статусу modified.

Подготовьте правки к коммиту с помощью git add.

`$ git add fileA.txt`

`$ git status`

On branch master
Changes to be committed: # все изменения готовы к коммиту
(use "git restore --staged `<file>`..." to unstage)
modified: fileA.txt

Теперь в коммит попадёт уже новая версия файла fileA.txt.

💡 Обратите внимание: хотя вывод команды git status очень похож на тот, который был после первого добавления файла fileA.txt, они всё же отличаются.

Когда совсем новый файл попадает в staging area, перед его названием указывается new file. Вот так: new file: fileA.txt.

Если файл уже однажды попадал в историю (с помощью коммита) и был изменён, после выполнения git add он будет записан уже так: modified: fileA.txt.

`## Файл добавлен в staging area, но после этого изменён`

Вы добавили файл в staging area, но перед самым коммитом вспомнили важную мелочь. Например, вместо одного восклицательного знака в конце строки Это файл A! нужно поставить три.

Откройте текстовый редактор и добавьте нужные правки. Теперь можно выполнить коммит, но в любой непонятной ситуации сначала стоит вызвать git status. Он покажет следующее.

`# изменили fileA.txt`

`$ git status`

On branch master
Changes to be committed:
(use "git restore --staged `<file>`..." to unstage)
modified: fileA.txt

Changes not staged for commit:
(use "git add `<file>`..." to update what will be committed)
(use "git restore `<file>`..." to discard changes in working directory)
modified: fileA.txt

Файл попал и в staged (Changes to be committed), и в modified (Changes not staged for commit). В staging area находится версия файла с одним восклицательным знаком, а в Changes not staged for commit — уже изменённая версия, с тремя.

Чтобы закоммитить самую свежую версию файла, нужно снова выполнить git add перед коммитом.

Теперь проверьте, как вы усвоили материал урока! Изучите скриншот с выводами команды git status для репозитория quiz-project.

Замечательно! Подытожим то, о чём рассказали в уроке:

- Команда git status всегда подскажет, что происходит с файлом: например, он добавлен в список «на коммит» или ещё вообще не отслеживается, или изменён.

-git status показывает явно следующие состояния файлов: untracked, staged и modified.

- git status подсказывает, какие команды можно выполнить, чтобы поменять состояние файла.

## Оформление сообщений к коммитам

То, как написаны сообщения коммитов, тоже может подчиняться определённым правилам. Иногда эти правила продиктованы культурой команды, а иногда техническими ограничениями.

Например, в выводе команды git log --oneline умещается максимум 72 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов».

В этом уроке рассмотрим несколько популярных подходов к оформлению сообщений коммитов. Но сначала разберём, почему такие сообщения важны и зачем соблюдать правила их оформления.

## Зачем вообще писать сообщения

У каждого коммита в Git есть сообщение — то, что передаётся после параметра -m. Например: git commit -m "Добавить урок про оформление сообщений коммитов".

Сообщения коммитов можно сравнить с надписями на коробках в кладовке. Если надписей нет, то нужную коробку будет сложно найти: придётся заглянуть в каждую, чтобы понять, что там. А если надписи есть, то нужная найдётся сразу.

Как и надпись на коробке, сообщение коммита должно помочь определить, что внутри. Например, надпись на коробке «всякое разное» не очень полезная. Сообщение коммита «небольшие исправления» тоже: непонятно, что было исправлено в таком коммите и зачем.

Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:

- относительно коротким, чтобы его было легко прочитать;

- информативным.

Вот пример полезного сообщения в репозитории новостного сайта: Исправление опечатки в заголовке главной страницы на хорватском. Такое сообщение даёт много информации:

- Исправление опечатки значит, что исправлена ошибка, которая была допущена при наборе. Такое исправление не меняет смысл. То есть, например, главному редактору не нужно перепроверять этот заголовок.

- На хорватском говорит о том, что переводчикам на другие языки этот коммит можно смело пропускать.

- В заголовке главной страницы указывает, где произошли изменения. Если, например, кто-то зайдёт на сайт и ему не понравится новый заголовок, он легко найдёт по истории (git log) автора этого коммита и спросит у него, почему заголовок теперь такой.

Пример плохого сообщения для того же коммита: [Исправлена опечатка](https://practicum.yandex.ru/trainer/git-basics/lesson/1add1d42-16f2-4df3-b230-d3362e10acb8/). Это сообщение даёт мало информации. В такой коммит придётся «заглядывать» — разбираться, что именно поменялось и зачем.

Распределите сообщения к коммитам по группам.

## Стили оформления

Все люди разные и у всех есть предпочтения — в том числе, как формулировать сообщения коммитов. Кто-то использует инфинитивы: Исправить сообщение об ошибке E123, кто-то — глаголы в прошедшем времени: Исправил…, кто-то — существительные: Исправление….

Без единообразия коммитов нет и эффективной работы в Git. Это может показаться мелочью, но когда коммиты с сообщениями в разных стилях идут друг за другом, их может быть сложно читать.

Чтобы упростить работу, команды или даже целые компании часто договариваются об определённом стиле (то есть о правилах) оформления сообщений коммитов.

Например, правила могут быть такие:

- длина сообщения от 30 до 72 символов;

- первое слово — глагол в инфинитиве («исправить», «дополнить», «добавить» и другие);

- и так далее.

Есть много подходов к оформлению сообщений коммитов, но мы расскажем о нескольких популярных. Их используют как отдельные команды, так и целые проекты.

## Корпоративный

Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, LGS-239 значит, что это 239-я задача в проекте LGS (сокращение от англ. logistics — «логистика»).

В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.

`$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами"`

Какие-то команды могут договариваться, с какой части речи начинать сообщение и какой длины оно должно быть, какие-то — нет. Но требование о наличии Jira-ID обычно строгое: оно позволяет автоматически связывать коммиты с задачами и проектами.

![Conventional Commits](https://pictures.s3.yandex.net/resources/Artboard20120copy2010_1402x_1686137247.png)

Стандарт **Conventional Commits** (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. Использовать его для других типов проектов (например, для перевода книги) было бы неудобно.

Conventional Commits предлагает такой формат коммита: `<type>`: <сообщение>. Первая часть type — это тип изменений. Таких типов достаточно много. Вот два примера:

- feat (сокращение от англ. feature) — для новой функциональности;

- fix (от англ. «исправить», «устранить») — для исправленных ошибок.

Более подробный список можно увидеть на сайте с описанием этого стиля.

Например, сообщение может быть таким.

`git commit -m "feat: добавить подсчёт суммы заказов за неделю"`

## GitHub-стиль

GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать #<номер задачи>. Например, вот так.

`$ git commit -m "Исправить #334, добавить график температуры"`

В таком случае GitHub свяжет коммит и задачу.

💡 Инфинитив и императив

Для сообщений на русском языке часто рекомендуют использовать инфинитивы. Например: Добавить тесты для PipkaService, Исправить ошибку #123 и так далее.

Для сообщений на английском рекомендуется использовать повелительное наклонение (англ. imperative). Например: Use library mega_lib_300, Fix exit button и так далее.

Эти рекомендации сложились исторически, и им следуют многие проекты.

Отлично! Правильно описывать коммиты — искусство, к которому стоит приобщиться как можно раньше. Хорошо, когда:

- сообщение коммита легко читается;

- оно информативное;

- все сообщения оформлены в одном стиле.

## Внедрение Mermaid в Markdown

- Для блока кода, отмеченного как mermaid:
  - система создаёт новый фрейм iframe,
  - необработанный код из блока передаётся его в Mermaid.js,
  - код преобразуется в диаграмму.
- Пример входного кода

```mermaid
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
```

- Результирующее изображение

## Поддерживаемые типы диаграмм

- Блок-схемы (Flowchart)
- Диаграммы состояния (Sequence diagram)
- Диаграммы Ганта (Gantt diagram)
- UML-диаграммы классов (Class diagram)
- Графы git (Git graph)
- ER-диаграммы (Entity Relationship Diagram)
- Диаграммы пользовательского пути (User Journey Diagram)
- Диаграммы последовательности (Sequence diagrams)
- Круговые диаграммы (Pie chart)

## Необходимое программное обеспечение

- Необходимо установить программу mmdc из проекта `https://github.com/mermaid-js/mermaid-cli`.

yarn global add @mermaid-js/mermaid-cli

## Блок-схемы (Flowchart)

### Синтаксис

- Ключевое слово: flowchart и аббревиатуры для указания направления.

- subgraph <имя>: задаёт поддиаграммы.

  - end: завершает описание поддиаграммы.

- Основная часть диаграммы — это узлы.

  - Текст на диаграмме узла берётся из названия.

  - Альтернативно можно указать отображаемый текст в квадратных скобках.

  - Форма узлов задаётся скобочными символами вокруг текста.

  - Для экранирования используют кавычки.

    - Всё содержимое в кавычках считается текстом.

- click: задаёт ссылку для узла.

click <узел> "<ссылка>" <\_blank>

- Ссылка заключается в кавычки.

- \_blank: указывает открыть ссылку в новой вкладке.

- Направление диаграммы:

  - TB: сверху вниз (top to bottom);

  - TD: сверху вниз (top-down);

  - BT: снизу вверх (bottom to top);

  - RL: справа налево (right to left);

  -LR: слева направо (left to right).

- style: задаёт оформление диаграммы.

style <узел> <style_tag:значение>,<style_tag:значение>

- Теги стилей:

  - fill: заливка;

  - stroke: цвет границы;

  - stroke-width: толщина границы;

  - color: цвет текста;

  - stroke-dasharray: пунктирная граница.

- classDef: задаёт класс, содержащий набор стилей.

classDef <имя_класса> <style_tag:значение>,<style_tag:значение>

- ::: указывает класс после имени узла.

### Примеры

- Блок

```mermaid
flowchart TB
     node
```

- Блок с текстом

```mermaid
flowchart TB
    node[Text]
```

- Формы узлов

```mermaid
flowchart TB
  node1[Форма1]
  node2(Форма2)
  node3([Форма3])
  node4[[Форма4]]
  node5[(Форма5)]
  node6((Форма6))
  node7>Форма7]
  node8{Форма8}
  node9{{Форма9}}
  node10[/Форма10/]
  node11[\Форма11\]
  node12[/Форма12\]
  node13[\Форма13/]
```

- Стрелки

```mermaid
flowchart TB
A-->B
C---D
E-.-F
G==>H
I--oJ
K--xL
```

- Стрелки с текстом

```mermaid
flowchart TD
A--Text---B
C---|Text|D
E-->|Text|F
G--Text-->H
I-.Text.->J
K==Text==>l
```

- Поддиаграммы

```mermaid
flowchart TB
 c1 --> a2
      subgraph one
          a1 --> a2
      end
      subgraph two
          b1 --> b2
      end
      subgraph three
          c1 --> c2
      end
```

Важно!!! Соблюдать табуляцию!

- Ссылки

```mermaid
flowchart TB
  A --> B
  B --> A
  B ==Text==> C
  C -.Text.- A
  click A "https://yamadharma.github.io/ru/post/2021/01/03/diagrams-mermaid/" _blank
  click B "http://www.github.com" _blank
```

- Стили

```mermaid
flowchart LR
    id1(Start)-->id2(Stop)
    style id1 fill:#3f3,stroke:3333,stroke-width:4px
    style id2 fill:#ff2400,stroke:#333,stroke-width:4px,color:#fff,stroke-dasharray: 12 5
```

- Классы стилей

```mermaid
 flowchart LR
      classDef class1 fill:#3f3,stroke:#333,stroke-width:4px
      classDef class2 fill:#ff2400,stroke:#333,stroke-width:4px,color:#fff,stroke-dasharray: 12 5

      A(Start):::class1 --> B(Stop):::class2
```

Basic Pie Chart

```mermaid
pie title NETFLIX
         "Time spent looking for movie" : 90
         "Time spent watching it" : 10
```

What Voldemort doesn't have?

```mermaid
pie title What Voldemort doesn't have?
         "FRIENDS" : 2
         "FAMILY" : 3
         "NOSE" : 45
```

Basic sequence diagram

```mermaid
sequenceDiagram
    Alice ->> Bob: Hello Bob, how are you?
    Bob-->>John: How about you John?
    Bob--x Alice: I am good thanks!
    Bob-x John: I am good thanks!
    Note right of John: Bob thinks a long<br/>long time, so long<br/>that the text does<br/>not fit on a row.

    Bob-->Alice: Checking with John...
    Alice->John: Yes... John, how are you?
```

Basic flowchart

```mermaid
graph LR
    A[Square Rect] -- Link text --> B((Circle))
    A --> C(Round Rect)
    B --> D{Rhombus}
    C --> D
```

Larger flowchart with some styling

```mermaid
graph TB
    sq[Square shape] --> ci((Circle shape))

    subgraph A
        od>Odd shape]-- Two line<br/>edge comment --> ro
        di{Diamond with <br/> line break} -.-> ro(Rounded<br>square<br>shape)
        di==>ro2(Rounded square shape)
    end

    %% Notice that no text in shape are added here instead that is appended further down
    e --> od3>Really long text with linebreak<br>in an Odd shape]

    %% Comments after double percent signs
    e((Inner / circle<br>and some odd <br>special characters)) --> f(,.?!+-*ز)

    cyr[Cyrillic]-->cyr2((Circle shape Начало));

     classDef green fill:#9f6,stroke:#333,stroke-width:2px;
     classDef orange fill:#f96,stroke:#333,stroke-width:4px;
     class sq,e green
     class di orange
```

SequenceDiagram: Loops, alt and opt

```mermaid
sequenceDiagram
    loop Daily query
        Alice->>Bob: Hello Bob, how are you?
        alt is sick
            Bob->>Alice: Not so good :(
        else is well
            Bob->>Alice: Feeling fresh like a daisy
        end

        opt Extra response
            Bob->>Alice: Thanks for asking
        end
    end
```

SequenceDiagram: Message to self in loop

```mermaid
sequenceDiagram
    participant Alice
    participant Bob
    Alice->>John: Hello John, how are you?
    loop HealthCheck
        John->>John: Fight against hypochondria
    end
    Note right of John: Rational thoughts<br/>prevail...
    John-->>Alice: Great!
    John->>Bob: How about you?
    Bob-->>John: Jolly good!
```

Sequence Diagram: Blogging app service communication

```mermaid
sequenceDiagram
    participant web as Web Browser
    participant blog as Blog Service
    participant account as Account Service
    participant mail as Mail Service
    participant db as Storage

    Note over web,db: The user must be logged in to submit blog posts
    web->>+account: Logs in using credentials
    account->>db: Query stored accounts
    db->>account: Respond with query result

    alt Credentials not found
        account->>web: Invalid credentials
    else Credentials found
        account->>-web: Successfully logged in

        Note over web,db: When the user is authenticated, they can now submit new posts
        web->>+blog: Submit new post
        blog->>db: Store post data

        par Notifications
            blog--)mail: Send mail to blog subscribers
            blog--)db: Store in-site notifications
        and Response
            blog-->>-web: Successfully posted
        end
    end

```

A commit flow diagram.

```mermaid
gitGraph:
    commit "Ashish"
    branch newbranch
    checkout newbranch
    commit id:"1111"
    commit tag:"test"
    checkout main
    commit type: HIGHLIGHT
    commit
    merge newbranch
    commit
    branch b2
    commit
```

```mermaid
mindmap
      root(Фёдор Щукин))
        Destinations
          Europe
            France(Paris)
            Italy(Rome)
            Russia(Moskau)
          Asia
            Japan(Tokyo)
            Сибирь(Новосибирск)
            Урал(Екатеринбург)
            Забайкалье(Чита)
            Дальний Восток(Владивосток)
        Budget
          Airfare
          Hotels
          Food
        Activities
          Sightseeing
          Adventure Sports
        Accommodation
          Hotels
          Vacation Rentals
```

```mermaid
graph LR;
    A--> B & C & D;
    B--> A & E;
    C--> A & E;
    D--> A & E;
    E--> B & C & D;
```

### Primer

```mermaid
flowchart TB
    A(need diagram) --> B(draw flow chart)
    B(draw flow chart) --> C(reposition arrows)
    C(reposition arrows) --> D(arrows go wonky)
    D(arrows go wonky) --try again--> B(draw flow chart)
    D(arrows go wonky) --> E(give up)
```

Primer

```mermaid
flowchart TB
    A{need diagram} --> B[(draw flow chart)]
    B[(draw flow chart)] --> C((reposition arrows))
    C((reposition arrows)) --> D(arrows go wonky)
    D(arrows go wonky) --try again--> B[(draw flow chart)]
    D(arrows go wonky) ==> E[/give up\]
```

Primer

```mermaid
    classDiagram
    class GameObject {
        -String Name
        -int PosX
        -int PosY
        +Despawn() void
    }
```

Primer

```mermaid
    classDiagram
    class GameObject {
        -String Name
        -int PosX
        -int PosY
        +Despawn() void
    }
    class DamageableObject {
        +int MaxHealth
        -int Health
        +IsDead() bool
        +TakeDamage(int damage) void
        +OnKilled() void
    }
    GameObject <|-- DamageableObject
```

Primer

```mermaid
classDiagram
    note "This is a note for the whole diagram"
    note for Player "This is a note on the Player class"
    class GameObject {
        +String Name
        +int PosX
        +int PosY
        +Despawn() void
    }
    class DamageableObject {
        <<abstract>>
        +int MaxHealth
        -int Health
        +IsDead() bool
        +TakeDamage(int damage) void
        +OnKilled()* void
    }
    class Player {
        -int Score
        -int LivesRemaining
        +OnKilled() void
    }
    class Monster {
        -int ThreatLevel
        -Color Color
        +MakeNoise(double decibelLevel) string
        +OnKilled() void
    }
    GameObject <|-- DamageableObject
    DamageableObject <|-- Player
    DamageableObject <|-- Monster
```

Primer

```mermaid
classDiagram
    Human *-- Cells : composed of
    Salesperson o-- Sales : makes
    Human <|-- Salesperson : is
```

```mermaid
flowchart TB
    A[Deploy to production] ==> B{Is It Friday?}
    B{Is It Friday?} --Yes--> C[Do not deploy!]
    B{Is It Friday?} --Noun--> D[Run deploy.sh to deploy!]
    C[Do not deploy!] --> E[Enjoy your weekend!]
    D[Run deploy.sh to deploy!] --> E[Enjoy your weekend!]
```

## Как откатиться назад, если «всё сломалось»

На разных этапах работы с Git могут происходить похожие ситуации:

- В список на коммит попал лишний файл (например, временный). Нужно «вынуть» его из списка.
- Последние несколько коммитов ошибочные: например, сделали не то, что было нужно, или нарушили логику. Хочется «откатить» сразу несколько коммитов, вернуть «как было вчера».
- Случайно изменился файл, который вообще не должен был меняться. Например, вы открыли не тот файл в редакторе и начали его исправлять.

В этом уроке рассмотрим такие случаи и научим вас «откатывать» нежелательные изменения.

## Выполнить unstage изменений — git restore --staged <file>

Допустим, вы создали или изменили какой-то файл и добавили его в список «на коммит» (staging area) с помощью git add, но потом передумали включать его туда. Убрать файл из staging поможет команда git restore --staged `<file>` (от англ. restore — «восстановить»).

💡 В выводе команды git status есть подсказка в скобках: use "git restore --staged `<file>`..." to unstage. Так что, даже если вы и забыли эту команду, Git напомнит вам.

В терминале это будет выглядеть примерно так.

`$ touch example.txt # создали ненужный файл`

`$ git add example.txt # добавили его в staged`

`$ git status # проверили статус`

```Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   example.txt
```

`$ git restore --staged example.txt`

`$ git status # проверили статус`

```Untracked files:
  (use "git add <file>..." to include in what will be committed)
        example.txt

no changes added to commit (use "git add" and/or "git commit -a")
# файл example.txt из staged вернулся обратно в untracked
```

Вызов git restore --staged example.txt перевёл example.txt из staged обратно в untracked.

Чтобы «сбросить» все файлы из staged обратно в untracked/modified, можно воспользоваться командой git restore --staged .: она сбросит всю текущую папку (.).

💡 Раньше для этой операции использовали команду git reset HEAD. Но git reset «перегруженная»: она умеет делать много разных действий в зависимости от переданных параметров. Чтобы было меньше путаницы, в Git была добавлена отдельная команда git restore.

## «Откатить» коммит — git reset --hard <commit hash>

Иногда нужно «откатить» то, что уже было закоммичено, то есть вернуть состояние репозитория к более раннему. Для этого используют команду git reset --hard <commit hash> (от англ. reset  — «сброс», «обнуление» и hard — «суровый»).

```$ git log --oneline # хеш можно найти в истории
7b972f5 (HEAD -> master) style: добавить комментарии, расставить отступы
b576d89 feat: добавить массив Expenses и цикл для добавления трат # вот сюда и вернёмся 4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses()
```

`$ git reset --hard b576d89`

`# теперь мы на этом коммите`

`HEAD is now at b576d89 feat: добавить массив Expenses и цикл для добавления трат`

Теперь коммит b576d89 стал последним: вся дальнейшая разработка будет вестись от него. Файл также вернулся к тому состоянию, в котором был в момент этого коммита. А коммит 7b972f5 Git просто удалил. Это можно проверить, снова запросив лог. Он покажет следующее.

`$ git log --oneline`

`b576d89 (HEAD -> master) feat: добавить массив Expenses и цикл для добавления трат
4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses()`

Вот так схематично выглядит весь процесс «отката» с помощью git reset --hard `<hash>`.

![процесс «отката»](https://pictures.s3.yandex.net/resources/M2_T6_1686651127.png)


Будьте осторожны с командой git reset --hard! При удалении коммитов можно потерять что-то нужное.

![Будьте осторожны с командой git reset --hard!](https://pictures.s3.yandex.net/resources/Artboard20120copy209_1402x_1686141684.png)

## «Откатить» изменения, которые не попали ни в staging, ни в коммит, — git restore `<file>`

Может быть так, что вы случайно изменили файл, который не планировали. Теперь он отображается в Changes not staged for commit (modified). Чтобы вернуть всё «как было», можно выполнить команду git restore `<file>`.

`# случайно изменили файл example.txt`

```$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   example.txt
```

`$ git restore example.txt`

```$ git status
On branch main
nothing to commit, working tree clean
```

Ура! Теперь вы знаете, как сделать шаг назад, если что-то пошло не так. Вот о чём мы рассказали:

- Команда git restore --staged `<file>` переведёт файл из staged обратно в modified или untracked.

- Команда git reset --hard `<commit hash>` «откатит» историю до коммита с хешем `<hash>`. Более поздние коммиты потеряются!

- Команда git restore `<file>` «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.

## Git может привести к ошибкам и неправильным коммитам.

Команда git restore --staged `<file>` убирает файлы из списка коммита.

Команда git reset --hard `<commit hash>` откатывает историю до указанного коммита.

Команда git restore `<file>` восстанавливает изменения файла до последней сохраненной версии.

## Практическая работа №3. Нужно откатить изменения

Говорят, что ошибаться — это нормально и даже хорошо. Каждая ошибка учит чему-то новому. Но ещё полезнее учиться на чужих ошибках.
В этой практической работе вы окунётесь в мир программирования вместе с нашим героем Геной: узнаете, какие опасности его подстерегали, и исправите типичные ошибки новичка с помощью инструментов «отката» Git. Поехали!

## Секреты на сцене



























