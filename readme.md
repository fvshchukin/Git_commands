# Шпаргалка по консольным командам Git

## Общее

Git — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). **Важно:** добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (git add), потом «сохраняем» (git commit).

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые, изменённые, проиндексированные (готовые к коммиту).

### Ключ к пониманию

Ключ к пониманию концепции git — знание о «трех деревьях»:

- Рабочая директория — файловая система проекта (те файлы, с которыми вы работаете).

* Индекс — список отслеживаемых git-ом файлов и директорий, промежуточное хранилище изменений (редактирование, удаление отслеживаемых файлов).

+ Директория .git/ — все данные контроля версий этого проекта (вся история разработки: коммиты, ветки, теги и пр.).

**Коммит** — «сохранение» (хранит набор изменений, сделанный в рабочей директории с момента предыдущего коммита). Коммит неизменен, его нельзя отредактировать.

У всех коммитов (кроме самого первого) есть один или более родительских коммитов, поскольку коммиты хранят изменения от предыдущих состояний.

### Простейший цикл работ:

* Редактирование, добавление, удаление файлов (собственно, работа).
* Индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).
* Коммит (фиксация изменений).
* Возврат к шагу 1 или отход ко сну.

### Указатели:
- **HEAD** — указатель на текущий коммит или на текущую ветку (то есть, в любом случае, на коммит). Указывает на родителя коммита, который будет создан следующим.
- **ORIG_HEAD** — указатель на коммит, с которого вы только что переместили HEAD (командой git reset ..., например).
- **Ветка** (master, develop etc.) — указатель на коммит. При добавлении коммита, указатель ветки перемещается с родительского коммита на новый.
- **Теги** — простые указатели на коммиты. Не перемещаются.

## Настройки

**Перед началом работы нужно выполнить некоторые настройки:**

*`git config --global user.name "Your Name" # указать имя, которым будут подписаны коммиты`*

*`git config --global user.email "e@w.com"  # указать электропочту, которая будет в описании коммитера`*

*`git config --global core.autocrlf true # Включит в преобразование окончаний строк из CRLF в LF`*

**И**

*`git config --global core.safecrlf true`*

*`git config -global core.editor vim (nano, code, pstorm, и т.д.)`*

## Указание неотслеживаемых файлов

Файлы и директории, которые не нужно включать в репозиторий, указываются в файле **.gitignore**. Обычно это устанавливаемые зависимости **(node_modules/, bower_components/)**, готовая сборка **build/** или **dist/** и подобные, создаваемые при установке или запуске. Каждый файл или директория указываются с новой строки, возможно использование шаблонов.

# Шпаргалка по bash

## Суть

**Консоль** — удобный и быстрый инструмент управления компьютером. Вводим команду текстом, получаем результат или сообщение об ошибке с указанием в чём ошибка.

Работая с консолью, мы всегда «находимся» в какой-то папке (это указано в строке над курсором). Если там написано **~**, то мы в папке пользователя (зависит от настроек Windows, чаще всего это **C:/Users/ВАШЕИМЯПОЛЬЗОВАТЕЛЯ/)**, если там **/d/projects**, мы в папке **D:/projects.**

## Файловая система

### Просмотр содержимого папки

`pwd                     # выводит текущи путь (сокращение от PRINT WORK DIRECTORY)`

`ls                      # показать содержимое папки`

`ls -l                   # отображает расширенную информацию о файлах и папках`

`ls -a                   # то же, но показывать и скрытые файлы и папки`

`ls -a -1                # то же, но в один столбец`

`ls -hF -1 --sort=extension # показать содержимое папки «красиво, в один столбец»`

`ls build/css            # показать содержимое папки ТЕКУЩАЯ_ПАПКА/build/css`

`ls /d/projects          # показать содержимое папки D:/projects`


## Перемещение по файловой системе

*Пользователь всегда находится в какой-то папке, она (или полный путь) всегда показана до области ввода команд.*

`cd projects             # переход в папку projects, которая есть текущей папке`

`cd /d/projects          # windows: переход в папку projects, расположенную по адресу D:/projects`

`cd /c/Program\ Files    # windows: переход в C/:Program Files`

`cd .                    # текущая директория`

`cd ..                   # переход к родительской папке`

`cd ~                    # домашняя директория`

`cd -                    # переход к последней рабочей папке`

## Создание папок и файлов

`mkdir project                        # создать папку с именем «project»`

`mkdir project project/css project/js # создать несколько папок`

`mkdir -p project/{css,js}            # то же, что выше`

`touch index.html                     # создать файл`

`touch index.html css/style.css js/script.js # создать файлы (папки css/ и js/ должны уже существовать)`

Чтобы не набирать имя папки целиком, наберите первые пару символов и нажмите **Tab** — произойдет автодополнение (если нет двух папок, начинающихся с введенных символов, иначе будут показаны сами эти папки). Справедливо для любой команды.

## Копирование файлов

`cp index.html catalog.html # копирование файла index.html в тот же каталог с переименованием в catalog.html`

`cp index.html old/         # копирование файла index.html в папку old/ (все произойдет в текущей папке)`

`cp temp/ temp2/ -r         # дублирование каталога`

## Переименование или перемещение файлов

`mv index.html old              # перемещение файла в папку`

`mv index.html old/new_name.txt # перемещение файла в папку с переименованием файла`

`mv order.txt orderNew.txt      # переименовать файл`

## Удаление папок и файлов

`rm ghost.png             # удалить файл`

`rm -rf old               # удалить папку и всё из нее`


# Алиасы

Для команд можно создавать алиасы (синонимы). Для этого в папке пользователя (OSX и linux) или в **C:/Users/ИМЯ_ПОЛЬЗОВАТЕЛЯ/.bashrc (Windows)** нужно вписать строки, наподобие **alias pro='cd /d/projects'** (одна строка в файле — один алиас)..

`alias                 # отобразит алиасы, которые уже заданы в системе`

`c='clear'       # создаст алиас который будет очищать консоль`

`unalias c             # удалит алиас " c "`

`unalias -a            # удалит все записанные алиасы`

## Разное

Подборка команд, показывающих бОльшую скорость работы с консолью, чем с GUI или просто удобных команд. Многие из них могут быть реализованы различными путями с GUI, что ничуть не умаляет удобства консоли.

`clear                 # очистить консоль`

`df -h                 # показать статистику использования пространства на дисках`

`grep -i -n --color 'carousel' index.html css/style.css # найти слово carousel в двух указанных файлах (с игнором регистра), вывести строки с этим словом и номера строк (искомое слово подсветить)`

`grep word -r project  # найти слово word во всех файлах в папке project`

`find . -iname '*ind*' # найти в текущей папке (и подпапках) все файлы, имена которых содержат ind и показать списком`

`ls -a >> file.txt     # записать в file.txt результат вывода команды ls -a`

`ls src/less/mixins    # показать содержимое папки с указанным путем без перехода в неё`

`echo  "Some text"     # вывод текста в консоль`

`chmod +x ./fileName   # сделать файл исполняемым`

`whoami                # выводит имя пользователя`

## Использование переменных

Переменные позволяют хранить в файле сценария информацию, например — результаты работы команд для использования их другими командами.

Существуют два типа переменных, которые можно использовать в bash-скриптах:

1. Переменные среды - переменные установленые в среде

`echo $HOME`

`echo "Env variable $HOME"`

2. Пользовательские переменные - хранят значение до тех пор, пока не завершится выполнение сценария.

`#!/bin/zsh`

`grade=5`

`person="Adam"`

`echo "$person is a good boy, he is in grade $grade"`

## Подстановка команд в переменные

Одна из самых полезных возможностей bash-скриптов — это **возможность извлекать информацию из вывода команд и назначать её переменным**, что позволяет использовать эту информацию где угодно в файле сценария.

Сделать это можно двумя способами.

1. С помощью значка обратного апострофа «`»

`mydir=`pwd``


2. С помощью конструкции $()

`mydir=$(pwd)`

А скрипт, в итоге, может выглядеть так:

`#!/bin/bash`

`mydir=$(pwd)`

`echo $mydir`

В ходе его работы вывод команды **pwd** будет сохранён в переменной **mydir**, содержимое которой, с помощью команды **echo**, попадёт в консоль.

# Математические операции

Для выполнения математических операций в файле скрипта можно использовать конструкцию вида **$((a+b))**

`#!/bin/bash`


`var1=$(( 5 + 5 ))`

`echo $var1`


`var2=$(( $var1 * 2 ))`

`echo $var2`

# Управляющая конструкция if-then

В некоторых сценариях требуется управлять потоком исполнения команд. Например, если некое значение больше пяти, нужно выполнить одно действие, в противном случае — другое. Подобное применимо в очень многих ситуациях, и здесь нам поможет управляющая конструкция if-then. В наиболее простом виде она выглядит так

`if команда`

`then`

`команды`

`fi` 

`#!/bin/bash`

`if pwd`

`then`

`echo "It works"`

`fi`

Пример: надо найти некоего пользователя в **/etc/passwd**, и если найти его удалось, сообщить о том, что он существует.

`#!/bin/bash`

`user=likegeeks`

`if grep $user /etc/passwd`

`then`

`echo "The user $user Exists"`

`fi`

# Управляющая конструкция if-then-else

Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией **if-then-else**. Вот как она устроена:

`#!/bin/bash`

`user=anotherUser`

`if grep $user /etc/passwd`

`then`

`echo "The user $user Exists"`

`else`

`echo "The user $user doesn’t exist"`

`fi`

# Конструкция CASE

Если вы столкнулись с парой различных возможных действий, то использование оператора **case** может быть более полезным, чем вложенные операторы **if**. Для более сложных условий используйте пример, как показано ниже

`case "$extension" in`

  `"jpg"|"jpeg") echo "It's image with jpeg extension." ;;`

 `"png")        echo "It's image with png extension."  ;;`

  `"gif")        echo "Oh, it's a giphy!"               ;;`

 `*)            echo "Woops! It's not image!"          ;;`

`esac`

# Циклы

В **Bash** есть четыре типа циклов: **for, while, until и select**.

+ **FOR**

`# 1`

`for arg in elem1 elem2 ... elemN`

`do`

  `# statements`

`done`

`# 2`

`for i in {1..5}; do echo $i; done`

`# 3`

`for (( i = 0; i < 10; i++ )); do`

  `echo $i`

`done``

`# 4`

`for FILE in $HOME/*.bash; do`

  `mv "$FILE" "${HOME}/scripts"`

  `chmod +x "${HOME}/scripts/${FILE}"`

`done`

* **WHILE** - Цикл **while** проверяет условие и перебирает последовательность команд, пока это условие истинно. Условие - это не что иное, как первичное значение, используемое в условиях **if..then**.

`while [[ condition ]]`

`do`

  `# statements`

`done`

`# Squares of numbers from 0 through 9`

`x=0`

`while [[ $x -lt 10 ]]; do # value of x is less than 10`

  `echo $(( x * x ))`

  `x=$(( x + 1 )) # increase x`

`done`

- **UNTIL** - Цикл **until** - полная противоположность цикла **while**. Какое-то время он проверяет условие теста, но продолжает цикл, пока это условие ложно

`until [[ condition ]]; do`

  `#statements`

`done`

В этом примере пользователю задается вопрос, какой диспетчер пакетов он хотел бы использовать. Затем он спросит, какой пакет мы хотим установить, и, наконец, приступит к его установке.

`PS3="Choose the package manager: "`

`select ITEM in bower npm gem pip`

`do`

  `echo -n "Enter the package name: " && read PACKAGE`

  `case $ITEM in`

    `bower) bower install $PACKAGE ;;`

    `npm)   npm   install $PACKAGE ;;`

    `gem)   gem   install $PACKAGE ;;`

    `pip)   pip   install $PACKAGE ;;`

  `esac`

  `break # avoid infinite loop`

`done`

* **LOOP CONTROL**- Бывают ситуации, когда нам нужно остановить цикл до его нормального завершения или перешагнуть через итерацию. В этих случаях мы можем использовать встроенные в оболочку операторы break и continue.

Оператор *break* используется для выхода из текущего цикла до его завершения Оператор continue проходит одну итерацию

`for (( i = 0; i < 10; i++ )); do`

  `if [[ $(( i % 2 )) -eq 0 ]]; then continue; fi`

  `echo $i`

`done`

# Сравнение чисел

Сравнения пишем в [ ] обязательно пробелы в скобках

`# eq - equal`

`# ge - greater equal`

`# gt - greater than`

`# le - less equal`

`# lt - less than

`# ne - not equal`  

`n1 -eq n2 # Возвращает истинное значение, если n1 равно n2.`

`n1 -ge n2 # Возвращает истинное значение, если n1 больше или равно n2.`

`n1 -gt n2 # Возвращает истинное значение, если n1 больше n2.`

`n1 -le n2 # Возвращает истинное значение, если n1 меньше или равно n2.`

`n1 -lt n2 # Возвращает истинное значение, если n1 меньше n2.`

`n1 -ne n2 # Возвращает истинное значение, если n1 не равно n2.`


`val1=6`

`if [ $val1 -gt 5 ]`

`then`

`echo "The test value $val1 is greater than 5"`

`else`

`echo "The test value $val1 is not greater than 5"`

`fi`

# Сравнение строк

В сценариях можно сравнивать и строковые значения.
Операторы сравнения выглядят довольно просто, однако у операций сравнения строк есть определённые особенности, которых мы коснёмся ниже. Вот список операторов.

`str1 = str2   # Проверяет строки на равенство, возвращает истину, если строки идентичны.`

`str1 != str2  # Возвращает истину, если строки не идентичны.`

`# операторы «>» и «<» необходимо экранировать с помощью обратной косой черты,`

`str1 \< str2   # Возвращает истину, если str1 меньше, чем str2.`

`str1 \> str2   # Возвращает истину, если str1 больше, чем str2.`

`-n str1       # Возвращает истину, если длина str1 больше нуля.`

`-z str1       # Возвращает истину, если длина str1 равна нулю.`


`#!/bin/bash`

`user ="likegeeks"`

`if [ $user = $USER ]`

`then`

`echo "The user $user  is the current logged in user"`

`fi`

# Проверки файлов

Kоманды позволяют проверять различные условия, касающиеся файлов

`-d file         # Проверяет, существует ли файл, и является ли он директорией.`

`-e file         # Проверяет, существует ли файл.`

`-f file         # Проверяет, существует ли файл, и является ли он файлом.`

`-r file         # Проверяет, существует ли файл, и доступен ли он для чтения.`

`-s file         # Проверяет, существует ли файл, и не является ли он пустым.`

`-w file         # Проверяет, существует ли файл, и доступен ли он для записи.`

`-x file         # Проверяет, существует ли файл, и является ли он исполняемым.`

`file1 -nt file2 # Проверяет, новее ли file1, чем file2.`

`file1 -ot file2 # Проверяет, старше ли file1, чем file2.`

`-O file         # Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.`

`-G file         # Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.`


`#!/bin/bash`

`mydir=/home/likegeeks`

`if [ -d $mydir ]                    # если файл сущетсвует и он является директорией`

`then`

`echo "The $mydir directory exists"  # выводим сообщение`

`cd $mydir                          # переходим в него`

`ls                                  # отображаем содержимое`

`else                                # ИНАЧЕ`

`echo "The $mydir directory does not exist"`

`fi`

# Операторы

Пайпы | - передает результат выполненной инструкции следующему пайпу

`# command1 | command2 | command3`

`ls -l | grep .md$ | less`

Точка с запятой ; - выполняет команды последовательно

`# command2 will be executed after command1`

`command1 ; command2`

Амперсанд **&** - оболочка выполняет команду асинхронно в подоболочке. Другими словами, эта команда будет выполняться в фоновом режиме

Двойной амперсанд (И) **&&** - вторая команды будет выполнена только в случае УСПЕШНОГО заверения первой команды

`# command2 will be executed if, and only if, command1 finishes successfully (returns 0 exit status)
command1 && command2`

Двойной пайп (ИЛИ) - вторая команды будет выполнена только в случае НЕУДАЧНОГО заверения первой команды

`# command2 will be executed if, and only if, command1 finishes unsuccessfully (returns code of error)
command1 || command2`

Тестовые [ ] - Эти выражения помогают нам указать результаты условного выражения. Используются обычно в блоках **if**

`# Single-line`

`if [[ 1 -eq 1 ]]; then echo "true"; fi`

`# Multi-line`

`if [[ 1 -eq 1 ]]; then`

  `echo "true"`

`fi`


`# Single-line`

`if [[ 2 -ne 1 ]]; then echo "true"; else echo "false"; fi`


`# Multi-line

`if [[ 2 -ne 1 ]]; then`

  `echo "true"`

`else`

  `echo "false"`

`fi`

## Длинный вывод в консоли: Vim

Вызов некоторых консольных команд приводит к необходимости очень длинного вывода в консоль (пример: вывод истории всех изменений в файле командой `**git log -p fileName.txt)**`. При этом прямо в консоли запускается редактор **Vim**. Он работает в нескольких режимах, из которых Вас заинтересуют режим вставки (редактирование текста) и нормальный (командный) режим. Чтобы попасть из **Vim** обратно в консоль, нужно в командном режиме ввести **:q**. Переход в командный режим из любого другого: **Esc**.

Если нужно что-то написать, нажмите **i** — это переход в режим вставки текста. Если нужно сохранить изменения, перейдите в командный режим и наберите **:w**.

# Vim (некоторые команды)

`# Нажатия кнопок`

`ESC     — переход в командный режим`

`i       — переход в режим редактирования текста`

`ZQ (зажат Shift, поочередное нажатие) — выход без сохранения`

`ZZ (зажат Shift, поочередное нажатие) — сохранить и выйти`

```bash


`# Нажатия кнопок`

`ESC     — переход в командный режим`

`i       — переход в режим редактирования текста`

`ZQ (зажат Shift, поочередное нажатие) — выход без сохранения`

`ZZ (зажат Shift, поочередное нажатие) — сохранить и выйти`


`# Ввод в командном режиме`

`:q!             — выйти без сохранения`

`:wq             — сохранить файл и выйти`

`:w filename.txt — сохранить файл как filename.txt`

## Консольные команды

Создать новый репозиторий

`git init             # создать новый проект в текущей директории`

`git init folder-name # создать новый проект в указанной директории`

## Клонирование репозитория

`# клонировать удаленный репозиторий в одноименную директорию`

`git clone https://github.com/cyberspacedk/Git-commands.git`    

`# клонировать удаленный репозиторий в директорию «FolderName»`

`git clone https://github.com/cyberspacedk/Git-commands.git FolderName` 

`# клонировать репозиторий в текущую директорию`

`git clone https://github.com:nicothin/web-design.git .`

## Просмотр изменений

`git status              # показать состояние репозитория
 (отслеживаемые, изменённые, новые файлы и пр.)`

`git diff                # сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)`

`git diff --color-words  # сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)`

`git diff index.html     # сравнить файл из рабочей директории и индекс`

`git diff HEAD           # сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)`

`git diff --staged       # сравнить индекс и коммит с HEAD`

`git diff master feature # посмотреть что сделано в ветке feature по сравнению с веткой master`

`git diff --name-only master feature # посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов`

`git diff master...feature # посмотреть что сделано в ветке feature с момента (коммита) расхождения с master`

## Добавление изменений в индекс

`git add .        # добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий`

`git add text.txt # добавить в индекс указанный файл (был изменён, был удалён или это новый файл)`

`git add -i       # запустить интерактивную оболочку для добавления в индекс только выбранных файлов`

`git add -p       # показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании`

## Удаление изменений из индекса

`git reset            # убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), антипод git add`

`git reset readme.txt # убрать из индекса изменения указанного файла (в рабочей директории изменения сохранятся)`

## Отмена изменений

`git checkout text.txt      # ОПАСНО: отменить изменения в файле, вернуть состояние файла, имеющееся в индексе`

`git reset --hard           # ОПАСНО: отменить изменения; вернуть то, что в коммите, на который указывает HEAD (незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)`

`git clean -df              # удалить неотслеживаемые файлы и директории`


## Коммиты

`git commit -m "Name of commit"    # зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение`

`git commit -a -m "Name of commit" # проиндексировать отслеживаемые файлы (ТОЛЬКО отслеживаемые, но НЕ новые файлы) и закоммитить, добавить сообщение`


## Отмена коммитов и перемещение по истории

Все коммиты, которые уже были отправлены в удалённый репозиторий, должны отменяться новыми коммитами **(git revert)**, дабы избежать проблем с историей разработки у других участников проекта.

`git revert HEAD --no-edit    # создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения`

`git revert b9533bb --no-edit # то же, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)`

**Все команды, приведённые ниже можно выполнять ТОЛЬКО если коммиты еще не были отправлены в удалённый репозиторий.**

`# ВНИМАНИЕ! Опасные команды, можно потерять незакоммиченные изменения`

`git commit --amend -m "Название"  # «перекоммитить» изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными из «отменяемого» коммита, но новым сообщением)`

`git reset --hard @~      # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита`

`git reset --hard 75e2d51 # передвинуть HEAD (и ветку) на коммит с указанным хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита`

`git reset --soft @~      # передвинуть HEAD (и ветку) на предыдущий коммит, но в рабочей директории и индексе оставить все изменения`

`git reset --soft @~2     # то же, но передвинуть HEAD (и ветку) на 2 коммита назад`

`git reset @~             # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию оставить как есть, индекс сделать таким, каким он был в момент предыдущего коммита (удобнее, чем git reset --soft @~, если индекс нужно задать заново)`

`# Почти как git reset --hard, но безопаснее: не получится потерять изменения в рабочей директории`

`git reset --keep @~      # передвинуть HEAD (и ветку) на предыдущий коммит, сбросить индекс, но в рабочей директории оставить изменения, если возможно (если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдёт)`

## Временно переключиться на другой коммит

`git checkout b9533bb # переключиться на коммит с указанным хешем (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита)`

`git checkout master  # переключиться на коммит, на который указывает master (переместить HEAD на коммит, на который указывает master, рабочую директорию вернуть к состоянию на момент этого коммита)`

## Переключиться на другой коммит и продолжить работу с него

Потребуется создание новой ветки, начинающейся с указанного коммита.

`git checkout -b new-branch 5589877   # создать ветку new-branch, начинающуюся с коммита c хешем 5589877 (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита, создать указатель на этот коммит (ветку) с указанным именем)`

## Восстановление изменений

`git checkout 5589877 index.html  # восстановить в рабочей директории указанный файл на момент указанного коммита (и добавить это изменение в индекс) (git reset index.html для удаления из индекса, но сохранения изменений в файле)`

## Копирование коммита (перенос коммитов)

`git cherry-pick 5589877          # скопировать на активную ветку изменения из указанного коммита, закоммитить эти изменения`

`git cherry-pick master~2..master # скопировать на активную ветку изменения из master (2 последних коммита)`

`git cherry-pick -n 5589877       # скопировать на активную ветку изменения из указанного коммита, но НЕ КОММИТИТЬ (подразумевается, что мы сами потом закоммитим)`

`git cherry-pick master..feature  # скопировать на активную ветку изменения из всех коммитов ветки feature с момента её расхождения с master (похоже на слияние веток, но это копирование изменений, а не слияние), закоммитить эти изменения; это может вызвать конфликт`

`git cherry-pick --abort    # прервать конфликтный перенос коммитов`

`git cherry-pick --continue # продолжить конфликтный перенос коммитов (сработает только после решения конфликта)`

## История коммитов

Выход из длинного лога вывода: **q**.

`git log master             # показать коммиты в указанной ветке`

`git log -2                 # показать последние 2 коммита в активной ветке`

`git log -2 --stat          # показать последние 2 коммита и статистику внесенных ими изменений`

`git log -p -22             # показать последние 22 коммита и внесенную ими разницу на уровне строк`

`git log --graph -10        # показать последние 10 коммитов с ASCII-представлением ветвления`

`git log --since=2.weeks    # показать коммиты за последние 2 недели`

`git log --after '2018-06-30' # показать коммиты, сделанные после указанной даты`

`git log index.html         # показать историю изменений файла index.html (только коммиты)`

`git log -5 index.html      # показать историю изменений файла index.html, последние 5 коммитов (только коммиты)`

`git log -p index.html      # показать историю изменений файла index.html (коммиты и изменения)`

`git log -G'myFunction' -p  # показать все коммиты, в которых менялись строки с myFunction (в кавычках регулярное выражение)`

`git log -L '/<head>/','/<\/head>/':index.html # показать изменения от указанного до указанного регулярных выражений в указанном файле`

`git log --grep fix         # показать коммиты, в описании которых есть буквосочетание fix (регистрозависимо, только коммиты текущей ветки)`

`git log --grep fix -i      # показать коммиты, в описании которых есть буквосочетание fix (регистроНЕзависимо, только коммиты текущей ветки)`

`git log --grep 'fix(ing|me)' -P # показать коммиты, в описании которых есть совпадения для регулярного выражения (только коммиты текущей ветки)`

`git log --pretty=format:"%h - %an, %ar : %s" -4 # показать последние 4 коммита с форматированием выводимых данных`

`git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short # мой формат вывода, висящий на алиасе оболочки`

`git log master..branch_99  # показать коммиты из ветки branch_99, которые не влиты в master`

`git log branch_99..master  # показать коммиты из ветки master, которые не влиты в branch_99`

`git log master...branch_99 --boundary -- graph # показать коммиты из указанных веток, начиная с их расхождения (коммит расхождения будет показан)`


`git show 60d6582           # показать изменения из коммита с указанным хешем`

`git show HEAD~             # показать данные о предыдущем коммите в активной ветке`

`git show @~                # аналогично предыдущему`

`git show HEAD~3            # показать данные о коммите, который был 3 коммита назад`

`git show my_branch~2       # показать данные о коммите, который был 2 коммита назад в указанной ветке`

`git show @~:index.html     # показать контент указанного файла на момент предыдущего (от HEAD) коммита`

`git show :/"подвал"        # показать самый новый коммит, в описании которого есть указанное слово (из любой ветки)`


## Удаление файла

`git rm text.txt    # удалить отслеживаемый неизменённый файл и проиндексировать это изменение`

`git rm -f text.txt # удалить отслеживаемый изменённый файл и проиндексировать это изменение`

`git rm -r log/     # удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение`

`git rm ind*        # удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение`

`git rm --cached readme.txt # удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)`

## Перемещение/переименование файлов

Для **git** не существует переименования. Переименование воспринимается как удаление старого файла и создание нового. Факт переименования может быть определен только после индексации изменения.

`git mv text.txt test_new.txt # переименовать файл «text.txt» в «test_new.txt» и проиндексировать это изменение`

`git mv readme_new.md folder/ # переместить файл readme_new.md в директорию folder/ (должна существовать) и проиндексировать это изменение`


## Кто написал строку

`git blame README.md --date=short -L 5,8 # показать строки 5-8 указанного файла и коммиты, в которых строки были добавлены`

## История изменений указателей (веток, HEAD)

`git reflog -20             # показать последние 20 изменений положения указателя HEAD`

`git reflog --format='%C(auto)%h %<|(20)%gd %C(blue)%cr%C(reset) %gs (%s)' -20 # то же, но с указанием давности действий`


## Ветки

`git branch                 # показать список веток`

`git branch -v              # показать список веток и последний коммит в каждой`

`git branch new_branch      # создать новую ветку с указанным именем на текущем коммите`

`git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите`

`git branch -f master 5589877  # переместить ветку master на указанный коммит`

`git branch -f master master~2 # переместить ветку master на 2 коммита назад`

`git checkout new_branch    # перейти в указанную ветку`

`git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё`

`git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё`

`git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix`

`git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)`

`git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов`

`git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния`

`git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)`

`git branch --merged        # показать ветки, уже слитые с активной`

`git branch --no-merged     # показать ветки, не слитые с активной`

`git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)`

`git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name`

`git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name`

`git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории`

`git branch --unset-upstream # завершить процесс переименования`


## Теги

`git tag v1.0.0               # создать тег с указанным именем на коммите, на который указывает HEAD`

`git tag -a -m 'В продакшен!' v1.0.1 master # создать тег с описанием на том коммите, на который смотрит ветка master`

`git tag -d v1.0.0            # удалить тег с указанным именем(ами)`

`git tag -n                   # показать все теги, и по 1 строке сообщения коммитов, на которые они указывают`

`git tag -n -l 'v1.*'         # показать все теги, которые начинаются с 'v1.*'`

## Временное сохранение изменений без коммита

`git stash     # временно сохранить незакоммиченные изменения и убрать их из рабочей директории`

`git stash pop # вернуть сохраненные командой git stash изменения в рабочую директорию`































